\chapter{EPICS General Purpose Tasks}

\section{Overview}

This chapter describes two sets of EPICS supplied general purpose tasks: 1) Callback,  and 2) Task Watchdog.

Often when writing code for an IOC there is no obvious task under which to execute. A good example is completion code 
for an asynchronous device support module. EPICS supplies the callback tasks for such code.

If an IOC tasks ``crashes" there is normally no one monitoring the vxWorks shell to detect the problem. EPICS provides a 
task watchdog task which periodically checks the state of other tasks. If  it finds that a monitored task has terminated or 
suspended it issues an error message and can also call other routines which can take additional actions. For example a 
subroutine record can arrange to be put into alarm if a monitored task crashes.

Since IOCs normally run autonomously, i.e. no one is monitoring the vxWorks shell, IOC code that issues \verb|printf| calls 
generates errors messages that are never seen. In addition the vxWorks implementation of fprintf requires much more 
stack space then \verb|printf| calls. Another problem with vxWorks is the \verb|logMsg| facility. \verb|logMsg| generates messages at 
higher priority then all other tasks except the shell. EPICS solves all of these problems via an error message handling 
facility. Code can call any of the routines \verb|errMessage|, \verb|errPrintf|, or \verb|errlogPrintf|. Any of these result in the 
error message being generated by a separate low priority task. The calling task has to wait until the message is handled but 
other tasks are not delayed. In addition the message can be sent to a system wide error message file.

\section{General Purpose Callback Tasks}
\label{sec:callbackThreads}

\subsection{Overview}

EPICS provides three sets of general purpose IOC callback tasks. The only difference between the task sets is their scheduling 
priority: low, medium or high. The low priority tasks runs at a priority just higher than Channel Access, the medium priority tasks at a 
priority about equal to the median of the periodic scan tasks, and the high priority tasks at a priority higher than the event scan task. The 
callback tasks are available for any software component that needs a task under which to run some job either immediately 
or after some delay. Jobs can also be cancelled during their delay period. The callback tasks register themselves with 
the task watchdog (described below). They are created with a generous amount of stack space and can thus be used for 
invoking record processing. For example the I/O event scanner uses the general purpose callback tasks.

The number of general purpose threads per priority level is configurable.
On SMP systems with multi-core CPUs, the throughput can be improved and the latency (time between job scheduling and processing) can be lowered by running multiple parallel callback tasks, which the OS scheduler may assign to different CPU cores. Parallel callback tasks must be explicitly enabled (see \ref{Parallel Callback Tasks} below), as this feature is disabled by default for compatibility reasons.

The following steps must be taken in order to use the general purpose callback tasks: 

\begin{enumerate}
\item Include callback definitions:

\index{callback.h}
\begin{lstlisting}[language=C]
#include <callback.h>
\end{lstlisting}

\item Provide storage for a structure that is a private structure for the callback tasks:

\index{CALLBACK}
\begin{lstlisting}[language=C]
CALLBACK mycallback;
\end{lstlisting}

It is permissible for this to be part of a larger structure, e.g.

\begin{lstlisting}[language=C]
struct {
    ...
    CALLBACK mycallback;
    ...
} ...
\end{lstlisting}

\item Make calls (in most cases these are actually macros) to initialize the fields in the \verb|CALLBACK|:

\index{callbackSetCallback}
\begin{lstlisting}[language=C]
void callbackSetCallback(CALLBACKFUNC func, CALLBACK *pcb);
\end{lstlisting}

This defines the callback routine to be executed. The first argument is the address of a function that will be given the address of the \verb|CALLBACK| and returns \verb|void|. The second argument is the address of the \verb|CALLBACK| structure.

\index{callbackSetPriority}
\begin{lstlisting}[language=C]
void callbackSetPriority(int, CALLBACK *pcb);
\end{lstlisting}

The first argument is the priority, which can have one of the values: \verb|priorityLow|, \verb|priorityMedium|, or 
\verb|priorityHigh|. These values are defined in \verb|callback.h|. The second argument is again the address of the 
\verb|CALLBACK| structure.

\index{callbackSetUser}
\begin{lstlisting}[language=C]
void callbackSetUser(void *, CALLBACK *pcb);
\end{lstlisting}

This call is used to save a pointer value that can be retrieved again using the macro:

\index{callbackGetUser}
\begin{lstlisting}[language=C]
void callbackGetUser(void *,CALLBACK *pcb);
\end{lstlisting}

If your callback function exists to process a single record inside calls to \verb|dbScanLock|/\verb|dbScanUnlock|, you can use this shortcut which provides the callback routine for you and sets the other two parameters at the same time 
(the user parameter here is a pointer to the record instance):

\index{callbackSetProcess}
\begin{lstlisting}[language=C]
void callbackSetProcess(CALLBACK *pcb, int prio, void *prec);
\end{lstlisting}

\item Whenever a callback request is desired just call one of the following:

\index{callbackRequest}
\index{callbackRequestProcessCallback}
\begin{lstlisting}[language=C]
int callbackRequest(CALLBACK *pcb);
int callbackRequestProcessCallback(CALLBACK *pcb, int prio, void *prec);
\end{lstlisting}

Both can be called from interrupt level code. The callback routine is passed a single argument, which is the same argument that was passed to \verb|callbackRequest|, i.e., the address of the \verb|CALLBACK| structure. The second routine is a shortcut for calling both \verb|callbackSetProcess| and \verb|callbackRequest|. Both return zero in case of success, or an error code (see below). 

The following delayed versions wait for the given time before queueing the callback routine for the relevant thread set to execute.

\index{callbackRequestDelayed}
\index{callbackRequestProcessCallbackDelayed}
\begin{lstlisting}[language=C]
void callbackRequestDelayed(CALLBACK *pCallback, double seconds);
void callbackRequestProcessCallbackDelayed(CALLBACK *pCallback,
    int Priority, void *pRec, double seconds);
\end{lstlisting}

These routines cannot be called from interrupt level code.
\end{enumerate}

\subsection{Syntax}

The following calls are provided:

\index{callbackInit}
\index{callbackShutdown}
\index{callbackSetCallback}
\index{callbackSetPriority}
\index{callbackSetUser}
\index{callbackGetUser}
\index{callbackSetProcess}
\index{callbackRequest}
\index{callbackRequestProcessCallback}
\index{callbackRequestDelayed}
\index{callbackRequestProcessCallbackDelayed}
\index{callbackCancelDelayed}
\index{callbackSetQueueSize}
Notes:
\begin{lstlisting}[language=C]
void callbackInit(void);
void callbackShutdown(void);

void callbackSetCallback(void *pcallbackFunction,
    CALLBACK *pcallback);
void callbackSetPriority(int priority, CALLBACK *pcallback);
void callbackSetUser(void *user, CALLBACK *pcallback);
void callbackGetUser(void *user, CALLBACK *pcallback);
void callbackSetProcess(CALLBACK *pcallback, int Priority, void *prec);

int callbackRequest(CALLBACK *);
int callbackRequestProcessCallback(
    CALLBACK *pCallback, int Priority, void *prec);
void callbackRequestDelayed(CALLBACK *pCallback, double seconds);
void callbackRequestProcessCallbackDelayed(
    CALLBACK *pCallback, int Priority, void *prec, double seconds);
void callbackCancelDelayed(CALLBACK *pcallback);
int callbackSetQueueSize(int size);
\end{lstlisting}

\begin{itemize}
\item \verb|callbackInit| and \verb|callbackShutdown| are performed automatically at IOC initialization or shutdown,
thus user code never calls these functions.

\item \verb|callbackSetCallback|, \verb|callbackSetPriority|, \verb|callbackSetUser|, and \verb|callbackGetUser| are 
actually macros.

\item \verb|Both callbackRequest| and \verb|callbackRequestProcessCallback| may be called from interrupt context. Both return zero for success, or one of the following error codes: \verb|S_db_notInit| for a NULL callback pointer, \verb|S_db_badChoice| for an illegal priority value, or \verb|S_db_bufFull| when the associated queue is full.

\item The delayed versions of the \verb|callbackRequest| routines wait the given time before queueing the callback.

\item \verb|callbackCancelDelayed| can be used to cancel a delayed callback.

\item \verb|callbackRequestProcessCallback| issues the calls:

\begin{lstlisting}[language=C]
callbackSetCallback(ProcessCallback, pCallback);
callbackSetPriority(Priority, pCallback);
callbackSetUser(pRec, pCallback);
callbackRequest(pCallback);
\end{lstlisting}

The routine \verb|ProcessCallback| was designed for asynchronous device completion and is defined as:

\begin{lstlisting}[language=C]
static void ProcessCallback(CALLBACK *pCallback)
{
    dbCommon    *pRec;
    struct rset *prset;
    
    callbackGetUser(pRec, pCallback);
    prset = (struct rset *)pRec->rset;
    dbScanLock(pRec);
    prset->process(pRec);
    dbScanUnlock(pRec);
}
\end{lstlisting}

\end{itemize}

\subsection{Example}

An example use of the callback tasks.

\begin{lstlisting}[language=C]
#include <callback.h>

static structure {
    char      begid[80];
    CALLBACK callback;
    char     endid[80];
} myStruct;

void myCallback(CALLBACK *pcallback)
{
    struct myStruct *pmyStruct;
    callbackGetUser(pmyStruct,pcallback)
    printf("begid=%s endid=%s\n", &pmyStruct->begid[0],
        &pmStruct->endid[0]);
}
example(char *pbegid, char*pendid)
{
    strcpy(&myStruct.begid[0],pbegid);
    strcpy(&myStruct.endid[0],pendid);
    callbackSetCallback(myCallback,&myStruct.callback);
    callbackSetPriority(priorityLow,&myStruct.callback);
    callbackSetUser(&myStruct,&myStruct.callback);
    callbackRequest(&myStruct.callback);
}
\end{lstlisting}

The example can be tested by issuing the following command to the vxWorks shell:

\begin{verbatim}
example("begin","end")
\end{verbatim}

This simple example shows how to use the callback tasks with your own structure that contains the \verb|CALLBACK| structure 
at an arbitrary location.

\subsection{Callback Queue}

The callback requests put the requests for each callback priority into a separate ring buffer. These buffers can by default 
hold up to 2000 requests. This limit can be changed by calling \verb|callbackSetQueueSize| before \verb|iocInit| in the 
startup file. The syntax is:

\index{callbackSetQueueSize}
\begin{lstlisting}[language=C]
int callbackSetQueueSize(int size)
\end{lstlisting}

\subsection{Parallel Callback Tasks}
\label{Parallel Callback Tasks}

To enable multiple parallel callback tasks, and set the number of tasks to be started for each priority level, call
\verb|callbackParallelThreads| before \verb|iocInit| in the startup file. The syntax is:

\index{callbackParallelThreads}
\begin{verbatim}
int callbackParallelThreads(int count, const char *prio)
\end{verbatim}

The count argument is the number of tasks to start, with 0 indicating to use the default (number of CPUs), and negative numbers indicating to use the number of CPUs minus the specified amount.

The prio argument specifies the priority level, with "" (empty string), "*", or NULL indicating to apply the definition to all priority levels.

The default value is stored in the variable \verb|callbackParallelThreadsDefault| (initialized to the number of CPUs), which can be changed using the iocShell's \verb|var| command.

\section{Task Watchdog}
\label{Task Watchdog}
\index{Task Watchdog}

EPICS provides a task that acts as a watchdog for other tasks. Any task can request to be watched, and most of the IOC 
tasks do this. A status monitoring subsystem in the IOC can register to be notified about any changes that occur. The 
watchdog task runs periodically and checks each task in its task list. If any task is suspended, an error message is 
displayed and any notifications made. The task watchdog provides the following features:

\begin{enumerate}
\item Include module:

\index{taskwd.h}
\begin{lstlisting}[language=C]
#include <taskwd.h>
\end{lstlisting}

\item Request by a task to be monitored:

\index{taskwdInsert}
\begin{lstlisting}[language=C]
void taskwdInsert(epicsThreadId tid, TASKWDFUNC callback, VOID *usr);
\end{lstlisting}

This adds the task with the specified \verb|tid| to the list of tasks to be watched, and makes any requested notifications 
that a new task has been registered. If \verb|tid| is given as zero, the \verb|epicsThreadId| of the calling thread is used 
instead. If \verb|callback| is not NULL and the task later becomes suspended, the callback routine will be called with 
the single argument \verb|usr|.

\item Remove task from list:

\index{taskwdRemove}
\begin{lstlisting}[language=C]
void taskwdRemove(epicsThreadId tid);
\end{lstlisting}

This routine must be called before the monitored task exits. It makes any requested notifications and removes the 
task from the list of tasks being watched. If \verb|tid| is given as zero, the \verb|epicsThreadId| of the calling thread is 
used instead.

\item Request to be notified of changes:

\index{taskwdMonitor}
\index{taskwdMonitorAdd}
\begin{lstlisting}[language=C]
typedef struct {
    void (*insert)(void *usr, epicsThreadId tid);
    void (*notify)(void *usr, epicsThreadId tid, int suspended);
    void (*remove)(void *usr, epicsThreadId tid);
} taskwdMonitor;

void taskwdMonitorAdd(const taskwdMonitor *funcs, void *usr);
\end{lstlisting}

This call provides a set of callbacks for the task watchdog to call when a task is registered or removed or when any 
task gets suspended. The \verb|usr| pointer given at registration is passed to the callback routine along with the \verb|tid| of 
the thread the notification is about. In many cases the \verb|insert| and \verb|remove| callbacks will be called from the 
context of the thread itself, although this is not guaranteed (the registration could be made by a parent thread for 
instance). The \verb|notify| callback also indicates whether the task went into or out of suspension; it is called in both 
cases, unlike the callbacks registered with \verb|taskwdInsert| and \verb|taskwdAnyInsert|.

\item Rescind notification request:

\index{taskwdMonitorDel}
\begin{lstlisting}[language=C]
void taskwdMonitorDel(const taskwdMonitor *funcs, void *usr);
\end{lstlisting}

This call removes a previously registered notification. Both \verb|funcs| and \verb|usr| must match the values given to 
\verb|taskwdMonitorAdd| when originally registered.

\item Print a report:

\index{taskwdShow}
\begin{lstlisting}[language=C]
void taskwdShow(int level);
\end{lstlisting}

If \verb|level| is zero, the number of tasks and monitors registered is displayed. For higher values the registered task 
names and their current states are also shown in tabular form.

\item The following routines are provided for backwards compatibility purposes, but are now deprecated:

\index{taskwdAnyInsert}
\begin{lstlisting}[language=C]
void taskwdAnyInsert(void *key, TASKWDANYFUNC callback, VOID *usr);
\end{lstlisting}

The callback routine will be called whenever any of the tasks being monitored by the task watchdog become 
suspended. \verb|key| must have a unique value because the task watchdog system uses this value to determine which 
entry to remove when \verb|taskwdAnyRemove| is called.

\index{taskwdAnyRemove}
\begin{lstlisting}[language=C]
void taskwdAnyRemove(void *key);
\end{lstlisting}

\verb|key| is the same value that was passed to \verb|taskwdAnyInsert|.
\end{enumerate}
