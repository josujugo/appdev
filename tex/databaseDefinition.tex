\chapter{Database Definition}
\index{Database Definition}

\section{Overview}

\index{database definitions}
This chapter describes database definitions.
The following definitions are described:

\begin{itemize}
\item Menu
\item Record Type
\item Device
\item Driver
\item Registrar
\item Variable
\item Function
\item Breakpoint Table
\item Record Instance
\end{itemize}

Record Instances are fundamentally different from the other definitions.
A file containing record instances should never contain any of the other definitions and vice-versa.
Thus the following convention is followed:

\begin{description}
\index{Database Definition File}
\item [Database Definition File] A file that contains any type of definition except record instances.

\index{Record Instance File}
\item [Record Instance File] A file that contains only record instance definitions.
\end{description}

This chapter also describes utility programs which operate on these definitions.

Any combination of definitions can appear in a single file or in a set of files related to each other via include statements.

\section{Summary of Database Syntax}

\index{Database Format -- Summary}
The following summarizes the Database Definition syntax:

\begin{verbatim}
path "path"
addpath "path"
include "filename"
#comment
menu(name) {
    include "filename"
    choice(choice_name, "choice_value")
    ...
}

recordtype(record_type) {}

recordtype(record_type) {
    include "filename"
    field(field_name, field_type) {
        asl(asl_level)
        initial("init_value")
        promptgroup(gui_group)
        prompt("prompt_value")
        special(special_value)
        pp(pp_value)
        interest(interest_level)
        base(base_type)
        size(size_value)
        extra("extra_info")
        menu(name)
        prop(yesno)
    }
    %C_declaration
    ...
}

device(record_type, link_type, dset_name, "choice_string")

driver(drvet_name)

registrar(function_name)

variable(variable_name)

breaktable(name) {
    raw_value eng_value
    ...
}
\end{verbatim}

The Following defines a Record Instance

\begin{verbatim}
record(record_type, record_name) {
    include "filename"
    field(field_name, "value")
    alias(alias_name)
    info(info_name, "value")
    ...
}
alias(record_name,alias_name)
\end{verbatim}

\section{General Rules for Database Definition}

\subsection{Keywords}

\index{Keywords}
The following are keywords, i.e. they may not be used as values unless they are enclosed in quotes:

\index{path}
\index{addpath}
\index{include}
\index{menu}
\index{choice}
\index{recordtype}
\index{field}
\index{device}
\index{driver}
\index{registrar}
\index{function}
\index{variable}
\index{breaktable}
\index{record}
\index{grecord}
\index{info}
\index{alias}
\begin{verbatim}
path
addpath
include
menu
choice
recordtype
field
device
driver
registrar
function
variable
breaktable
record
grecord
info
alias
\end{verbatim}

\subsection{Unquoted Strings}

\index{Unquoted String}
In the summary section, some values are shown as quoted strings and some unquoted.
The actual rule is that any string consisting of only the following characters does not need to be quoted unless it contains one of the above keywords:

\begin{verbatim}
a-z A-Z 0-9 _ - : . [ ] < > ;
\end{verbatim}

These are also the legal characters for process variable names.
Thus in many cases quotes are not needed.

\subsection{Quoted Strings}

\index{Quoted String}
A quoted string can contain any ascii character except the quote character \verb|"|.
The quote character itself can given by using a back-slash (\verb|\|) as an escape character.
For example \verb|"\""| is a quoted string containing a single double-quote character.

\subsection{Macro Substitution}

\index{Macro Substitution}
Macro substitutions are permitted inside quoted strings.
Macro instances take the form:

\begin{verbatim}
$(name)
\end{verbatim}

or

\begin{verbatim}
${name}
\end{verbatim}

There is no distinction between the use of parentheses or braces for delimiters, although the opening and closing characters must match for each macro instance.
A macro name can be constructed using other macros, for example:

\begin{verbatim}
$(name_$(sel))
\end{verbatim}

A macro instance can also provide a default value that is used when no macro with the given name has been defined.
The default value can itself be defined in terms of other macros if desired, but may not contain any unescaped comma characters.
The syntax for specifying a default value is as follows:

\begin{verbatim}
$(name=default)
\end{verbatim}

Finally macro instances can also set the values of other macros which may (temporarily) override any existing values for those macros, but the new values are in scope only for the duration of the expansion of this particular macro instance.
These definitions consist of \verb|name=value| sequences separated by commas, for example:

\begin{verbatim}
$(abcd=$(a)$(b)$(c)$(d),a=A,b=B,c=C,d=D)
\end{verbatim}

\subsection{Escape Sequences}
\label{subsec:Escape Sequences}

\index{Escape Sequence}
The database routines translate standard C escape sequences inside database field value strings only.
The standard C escape sequences supported are:

\begin{verbatim}
\a \b \f \n \r \t \v \\ \' \" \ooo \xhh
\end{verbatim}

\verb|\ooo| represents an octal number with 1, 2, or 3 digits.
\verb|\xhh| represents a hexadecimal number which may have any number of hex digits, although only the last 2 will be represented in the character generated.

\subsection{Comments}

\index{comment -- Database Definitions}
The comment symbol is ``\#''.
Whenever the comment symbol appears outside of a quoted string, it and all subsequent characters through the end of the line will be ignored.

\subsection{Define before referencing}

In general items cannot be referenced until they have been defined.
For example a \verb|device| definition cannot appear until the \verb|recordtype| that it references has been defined or at least declared.
Another example is that a record instance cannot appear until its associated record type has been defined.

One notable exception to this rule is that within a \verb|recordtype| definition a menu field may reference a menu that has not been included directly by the record's \verb|.dbd| file.

\subsection{Multiple Definitions}

\index{Multiple Definitions}
If a menu, device, driver, or breakpoint table is defined more than once, then only the first instance will be used.
Subsequent definitions may be compared to the first one and an error reported if they are different (the \verb|dbdExpand.pl| program does this, the IOC currently does not).
Record type definitions may only be loaded once; duplicates will cause an error even if the later definitions are identical to the first.
However a record type declaration may be used in place of the record type definition in \verb|.dbd| files that define device support for that type.

Record instance definitions are (normally) cumulative, so multiple instances of the same record may be loaded and each time a field value is encountered it replaces the previous value.

\subsection{Filename Extensions}

\index{filename extension conventions}
By convention:

\begin{itemize}
\item Record instances files have the extension ``\verb|.db|'' or ``\verb|.vdb|'' if the file also contains visual layout information

\item Database definition files have the extension ``\verb|.dbd|''

\end{itemize}

\section{Database Definition Statements}
\index{database definition statements}

\subsection{\texttt{path addpath} -- Path Definition}

\index{path -- Database Definitions}
\index{addpath -- Database Definitions}
\subsubsection{Format}

\begin{verbatim}
path "dir:dir...:dir"
addpath "dir:dir...:dir
\end{verbatim}

The path string follows the standard convention for the operating system, i.e. directory names are separated by a colon ``\verb|:|'' on Unix
and a semicolon ``\verb|;|'' on Windows.

The \verb|path| statement specifies the current search path for use when loading database and database definition files.
The \verb|addpath| statement appends directories to the current path.
The path is used to locate the initial database file and included files.
An empty path component at the beginning, middle, or end of a non-empty path string means search the current directory.
For example:

\begin{verbatim}
nnn::mmm    # Current directory is between nnn and mmm
:nnn        # Current directory is first
nnn:        # Current directory is last
\end{verbatim}

Utilities which load database files (\verb|dbExpand|, \verb|dbLoadDatabase|, etc.) allow the user to specify an initial path.
The \verb|path| and \verb|addpath| commands can be used to change or extend that initial path.

The initial path is determined as follows:

\begin{enumerate}
\item If path is provided with the command, it is used.
Else:

\item If the environment variable \verb|EPICS_DB_INCLUDE_PATH| is defined, it is used.
Else:

\item the path is ``\verb|.|'', i.e. the current directory.
\end{enumerate}

The search path is not used at all if the filename being searched for contains a \verb|/| or \verb|\| character.
The first instance of the specified filename is used.

\subsection{\texttt{include} -- Include Statement}

\index{include -- Database Definitions}
\subsubsection{Format}

\begin{verbatim}
include "filename"
\end{verbatim}

An include statement can appear at any place shown in the summary.
It uses the search path as described above to locate the named file.

\subsection{\texttt{menu} -- Menu Definition}
\index{menu -- Database Definitions}

\subsubsection{Format}

\begin{verbatim}
menu(name) {
    choice(choice_name, "choice_string")
    ...
}
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\item [name] Name for menu. This is the unique name identifying the menu.
If duplicate definitions are specified, only the first is used.

\item [choice\_name] The name used in the \verb|enum| generated by \verb|dbdToMenuH.pl| or \verb|dbdToRecordtypeH.pl|.
This must be a legal C/C++ identifier.

\item [choice\_string] The text string associated with this particular choice.
\end{description}

\subsubsection{Example}

\begin{verbatim}
menu(menuYesNo) {
    choice(menuYesNoNO, "NO")
    choice(menuYesNoYES, "YES")
}
\end{verbatim}

\subsection{\texttt{recordtype} -- Record Type Definition}
\index{record type -- Database Definitions}

\subsubsection{Format}

\begin{verbatim}
recordtype(record_type) {}

recordtype(record_type) {
    field(field_name, field_type) {
        asl(as_level)
        initial("init_value")
        promptgroup(gui_group)
        prompt("prompt_value")
        special(special_value)
        pp(pp_value)
        interest(interest_level)
        base(base_type)
        size(size_value)
        extra("extra_info")
        menu(name)
        prop(yesno)
    }
    %C_declaration
    ...
}
\end{verbatim}

\index{record type declaration}
A record type statement that provides no field descriptions is a declaration, analagous to a function declaration (prototype) or forward definition in C.
It allows the given record type name to be used in circumstances where the full record type definition is not needed.

\subsubsection{Field Descriptor Rules}

\index{field descriptor rules}
\begin{description}

\index{asl -- field descriptor rules}
\item [asl] Sets the Access Security Level for the field.
Access Security is discussed in chapter \ref{Access Security}.

\index{initial -- field descriptor rules}
\item [initial] Provides an initial (default) value for the field.

\index{promptgroup -- field descriptor rules}
\item [promptgroup] The group to which the field belongs, for database configuration tools.

\index{prompt -- field descriptor rules}
\item [prompt] A prompt string for database configuration tools.
Optional if \verb|promptgroup| is not defined.

\index{special -- field descriptor rules}
\item [special] If specified, special processing is required for this field at run time.

\index{pp -- field descriptor rules}
\item [pp] Whether a passive record should be processed when Channel Access writes to this field.

\index{interest -- field descriptor rules}
\item [interest] Interest level for the field.

\index{base -- field descriptor rules}
\item [base] For integer fields, the number base to use when converting the field value to a string.

\index{size -- field descriptor rules}
\item [size] Must be specified for \verb|DBF_STRING| fields.

\index{extra -- field descriptor rules}
\item [extra] Must be specified for \verb|DBF_NOACCESS| fields.

\index{menu -- field descriptor rules}
\item [menu] Must be specified for \verb|DBF_MENU| fields.
It is the name of the associated menu.

\index{prop -- field descriptor rules}
\item [prop] Must be \verb|YES| or \verb|NO| (default).
Indicates that the field holds Channel Access meta-data.
\end{description}

\subsubsection{Definitions}

\begin{description}
\index{record\_type -- record type definition}
\item [record\_type] The unique name of the record type.
Duplicate definitions are not allowed and will be rejected.

\index{field\_name -- field definition}
\item [field\_name] The field name, which must be a valid C and C++ identifier.
When include files are generated, the field name is converted to lower case for use as the record structure member name.
If the lower-case version of the field name is a C or C++ keyword, the original name will be used for the structure member name instead.
Previous versions of EPICS required the field name be a maximum of four all upper-case characters, but these restrictions no longer apply.

\index{field\_type -- field definition}
\item [field\_type] This must be one of the following values:

\begin{itemize}
\item \verb|DBF_STRING|
\item \verb|DBF_CHAR|, \verb|DBF_UCHAR|
\item \verb|DBF_SHORT|, \verb|DBF_USHORT|
\item \verb|DBF_LONG|, \verb|DBF_ULONG|
\item \verb|DBF_FLOAT|, \verb|DBF_DOUBLE|
\item \verb|DBF_ENUM|, \verb|DBF_MENU|, \verb|DBF_DEVICE|
\item \verb|DBF_INLINK|, \verb|DBF_OUTLINK|, \verb|DBF_FWDLINK|
\item \verb|DBF_NOACCESS|
\end{itemize}

\index{as\_level -- field definition}
\item [as\_level] This must be one of the following values:

\begin{itemize}
\item \verb|ASL0|
\item \verb|ASL1|  (default value)
\end{itemize}

Fields which operators normally change are assigned \verb|ASL0|.
Other fields are assigned \verb|ASL1|.
For example, the \verb|VAL| field of an analog output record is assigned \verb|ASL0| and all other fields \verb|ASL1|.
This is because only the \verb|VAL| field should be modified during normal operations.

\index{init\_value -- field definition}
\item [init\_value] A legal value for data type.

\index{prompt\_value -- field definition}
\item [prompt\_value] A prompt value for database configuration tools.

\index{gui\_group -- field definition}
\item [gui\_group] This must be one of the following:

\begin{itemize}
\item \verb|GUI_COMMON|
\item \verb|GUI_ALARMS|
\item \verb|GUI_BITS1|
\item \verb|GUI_BITS2|
\item \verb|GUI_CALC|
\item \verb|GUI_CLOCK|
\item \verb|GUI_COMPRESS|
\item \verb|GUI_CONVERT|
\item \verb|GUI_DISPLAY|
\item \verb|GUI_HIST|
\item \verb|GUI_INPUTS|
\item \verb|GUI_LINKS|
\item \verb|GUI_MBB|
\item \verb|GUI_MOTOR|
\item \verb|GUI_OUTPUT|
\item \verb|GUI_PID|
\item \verb|GUI_PULSE|
\item \verb|GUI_SELECT|
\item \verb|GUI_SEQ1|
\item \verb|GUI_SEQ2|
\item \verb|GUI_SEQ3|
\item \verb|GUI_SUB|
\item \verb|GUI_TIMER|
\item \verb|GUI_WAVE|
\item \verb|GUI_SCAN|

This information is for use by Database Configuration Tools.
This is defined only for fields that can be given values by database configuration tools.
File \verb|guigroup.h| contains all possible definitions.
This allows database configuration tools to group fields together by functionality, not just order them by name.
This feature has seldom been used, so many record types do not have appropriate values assigned to some fields.

\end{itemize}

\index{special\_value -- field definition}
\item [special\_value] Must be one of the following:

\begin{itemize}
\index{SPC\_MOD}
\item \verb|SPC_MOD| -- Notify record support when modified.
The record support \verb|special| routine will be called whenever the field is modified by the database access routines.

\index{SPC\_NOMOD}
\item \verb|SPC_NOMOD| -- No external modifications allowed.
This value disables external writes to the field, so it can only be set by the record or device support module.

\index{SPC\_DBADDR}
\item \verb|SPC_DBADDR| -- Use this if the record support's \verb|cvt_dbaddr| routine should be called to adjust the field description when code outside of the record or device support makes a connection to the field.

The following values are for database common fields.
They must \emph{not} be used for record specific fields:

\index{SPC\_SCAN}
\item \verb|SPC_SCAN| -- Scan related field.

\index{SPC\_ALARMACK}
\item \verb|SPC_ALARMACK| -- Alarm acknowledgment field.

\index{SPC\_AS}
\item \verb|SPC_AS| -- Access security field.

The following values are deprecated, use \verb|SPC_MOD| instead:

\item An integer value greater than 103.

\index{SPC\_RESET}
\item \verb|SPC_RESET| -- a reset field is being modified.

\index{SPC\_LINCONV}
\item \verb|SPC_LINCONV| -- A linear conversion field is being modified.

\index{SPC\_CALC}
\item \verb|SPC_CALC| -- A calc field is being modified.
\end{itemize}

\index{pp\_value -- field definition}
\item [pp\_value] Should a passive record be processed when Channel Access writes to this field?
The allowed values are:

\begin{itemize}
\item \verb|FALSE| (default)
\item \verb|TRUE|
\end{itemize}

\index{interest\_level -- field definition}
\item [interest\_level] An interest level for the \verb|dbpr| command.

\index{base -- field definition}
\item [base] For integer type fields, the default base.
The legal values are:

\begin{itemize}
\item \verb|DECIMAL| (Default)
\item \verb|HEX|
\end{itemize}

\index{size\_value -- field definition}
\item [size\_value] The number of characters for a \verb|DBF_STRING| field.

\index{extra\_info -- field definition}
\item [extra\_info] For \verb|DBF_NOACCESS| fields, this is the C language definition for the field.
The definition must end with the fieldname in lower case.

\item [\%C\_declaration] A percent sign \verb|%| inside the record body introduces a line of code that is to be included in the generated C header file.
\end{description}

\subsubsection{Example}

The following is the definition of the event record type:

\begin{verbatim}
recordtype(event) {
    include "dbCommon.dbd" 
    field(VAL,DBF_USHORT) {
        prompt("Event Number To Post")
        promptgroup(GUI_INPUTS)
        asl(ASL0)
    }
    field(INP,DBF_INLINK) {
        prompt("Input Specification")
        promptgroup(GUI_INPUTS)
        interest(1)
    }
    field(SIOL,DBF_INLINK) {
        prompt("Sim Input Specifctn")
        promptgroup(GUI_INPUTS)
        interest(1)
    }
    field(SVAL,DBF_USHORT) {
        prompt("Simulation Value")
    }
    field(SIML,DBF_INLINK) {
        prompt("Sim Mode Location")
        promptgroup(GUI_INPUTS)
        interest(1)
    }
    field(SIMM,DBF_MENU) {
        prompt("Simulation Mode")
        interest(1)
        menu(menuYesNo)
    }
    field(SIMS,DBF_MENU) {
        prompt("Sim mode Alarm Svrty")
        promptgroup(GUI_INPUTS)
        interest(2)
        menu(menuAlarmSevr)
    }
}
\end{verbatim}

\subsection{\texttt{device} -- Device Support Declaration}

\index{device -- Database Definitions}
\subsubsection{Format}

\begin{verbatim}
device(record_type, link_type, dset_name, "choice_string")
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{record\_type -- device definition}
\item [record\_type] Record type.
The combination of \verb|record_type| and \verb|choice_string| must be unique.
If the same combination appears more than once, only the first definition is used.

\index{link\_type -- device definition}
\item [link\_type] Link type. This must be one of the following:

\begin{itemize}
\item \verb|CONSTANT|
\item \verb|PV_LINK|
\item \verb|VME_IO|
\item \verb|CAMAC_IO|
\item \verb|AB_IO|
\item \verb|GPIB_IO|
\item \verb|BITBUS_IO|
\item \verb|INST_IO|
\item \verb|BBGPIB_IO|
\item \verb|RF_IO|
\item \verb|VXI_IO|
\end{itemize}

\index{dset\_name -- device definition}
\item [dset\_name] The name of the device support entry table for this device support.

\index{choice\_string -- device definition}
\item [choice\_string] The \verb|DTYP| choice string for this device support.
A \verb|choice_string| value may be reused for different record types, but must be unique for each specific record type.
\end{description}

\subsubsection{Examples}

\begin{verbatim}
device(ai,CONSTANT,devAiSoft,"Soft Channel")
device(ai,VME_IO,devAiXy566Se,"XYCOM-566 SE Scanned")
\end{verbatim}

\subsection{\texttt{driver} -- Driver Declaration}

\index{driver -- database definition}
\subsubsection{Format}

\begin{verbatim}
driver(drvet_name)
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{drvet\_name -- driver definition}
\item [drvet\_name] If duplicates are defined, only the first is used.

\end{description}

\subsubsection{Examples}

\begin{verbatim}
driver(drvVxi)
driver(drvXy210)
\end{verbatim}

\subsection{\texttt{registrar} -- Registrar Declaration}

\index{registrar -- Database Defintions}
\subsubsection{Format}

\begin{verbatim}
registrar(function_name)
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{function\_name -- registrar definition}
\item [function\_name] The name of an C function that accepts no arguments, returns \verb|void| and has been marked in
its source file with an \index{epicsExportRegistrar}\verb|epicsExportRegistrar| declaration, e.g.
\end{description}

\begin{verbatim}
static void myRegistrar(void);
epicsExportRegistrar(myRegistrar);
\end{verbatim}

This can be used to register functions for use by subroutine records or that can be invoked from iocsh. The example 
application described in Section \ref{Example IOC Application}, ``Example IOC Application'' on page \pageref{Example IOC Application}
gives an example of how to register functions for subroutine records.

\subsubsection{Example}

\begin{verbatim}
registrar(myRegistrar)
\end{verbatim}

\subsection{\texttt{variable} -- Variable Declaration}

\index{variable -- Database Definitions}
\subsubsection{Format}

\begin{verbatim}
variable(variable_name[, type])
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{variable\_name -- variable definition}
\item [variable\_name] The name of a C variable which has been marked in its source file with an 
\index{epicsExportAddress}\verb|epicsExportAddress| declaration.

\index{type -- variable definition}
\item [type] The C variable's type.
If not present, \verb|int| is assumed.
Currently only \verb|int| and \verb|double| variables are supported.
\end{description}

This registers a diagnostic/configuration variable for device or driver support or a subroutine record subroutine so that
the variable can be read and set with the iocsh \verb|var| command (see Section \ref{Utility Commands} on page \pageref{Utility Commands}).
The example application described in Section \ref{Example IOC Application} on page \pageref{Example IOC Application}
provides an example of how to register a debug variable for a subroutine record.

\subsubsection{Example}

In an application C source file:

\begin{lstlisting}[language=C]
#include <epicsExport.h>

static double myParameter;
epicsExportAddress(double, myParameter);
\end{lstlisting}

In an application database definition file:

\begin{verbatim}
variable(myParameter, double)
\end{verbatim}

\subsection{\texttt{function} -- Function Declaration}

\index{function -- Database Definitions}
\subsubsection{Format}

\begin{verbatim}
function(function_name)
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{function\_name -- function definition}
\item [function\_name] The name of a C function which is exported from its source file in an \index{epicsRegisterFunction}\verb|epicsRegisterFunction| declaration.
\end{description}

This registers a function so that it can be found in the function registry for use by record types such as sub or aSub which refer to the function by name.
The example application described in Section \ref{Example IOC Application} on page \pageref{Example IOC Application} provides an example of how to register functions for a subroutine record.

\subsubsection{Example}

In an application C source file:

\begin{lstlisting}[language=C]
#include <registryFunction.h>
#include <epicsExport.h>

static long myFunction(void *argp) {
    /* my code ... */
}
epicsRegisterFunction(myFunction);
\end{lstlisting}

In an application database definition file:

\begin{verbatim}
function(myFunction)
\end{verbatim}

\subsection{\texttt{breaktable} -- Breakpoint Table}

\index{breakpoint table -- Database Definitions}
\index{breaktable}
\subsubsection{Format}

\begin{verbatim}
breaktable(name) {
    raw_value eng_value
    ...
}
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{name -- breakpoint table}
\item [name] Name, which must be alpha-numeric, of the breakpoint table.
If duplicates are specified the first is used.

\index{raw\_value -- breakpoint table}
\item [raw\_value] The raw value, i.e. the actual ADC value associated with the beginning of the interval.

\index{eng\_value -- breakpoint table}
\item [eng\_value] The engineering value associated with the beginning of the interval.
\end{description}

\subsubsection{Example}

\begin{verbatim}
breaktable(typeJdegC) {
    0.000000 0.000000
    365.023224 67.000000
    1000.046448 178.000000
    3007.255859 524.000000
    3543.383789 613.000000
    4042.988281 692.000000
    4101.488281 701.000000
}
\end{verbatim}

\subsection{\texttt{record} -- Record Instance}

\index{record instance -- Database Definitions}
\index{record}
\subsubsection{Format}

\begin{verbatim}
record(record_type, record_name) {
    alias(alias_name)
    field(field_name, "field_value")
    info(info_name, "info_value")
    ...
}
alias(record_name, alias_name)
\end{verbatim}

\subsubsection{Definitions}

\begin{description}
\index{record\_type -- record instance definition}
\item [record\_type] The record type.

\index{record\_name -- record instance definition}
\item [record\_name] The record name.
This must be composed out of only the following characters:

\begin{verbatim}
a-z A-Z 0-9 _ - + : [ ] < > ;
\end{verbatim}

NOTE: If macro substitutions are used the name must be quoted.

If duplicate definitions are given for the same record, then the last value given for each field is the value assigned to the field.

\index{alias\_name -- record instance definition}
\item [alias\_name] An alternate name for the record, following the same rules as the record name.

\index{field\_name -- record instance definition}
\item [field\_name] A field name.

\index{field value -- record instance definition}
\item [field\_value] A value for the named field, appropriate for its particular field type.
When given inside double quotes the field value string may contain escaped characters which will be translated appropriately when loading the database.
See section \ref{subsec:Escape Sequences} for the list of escaped characters supported.
Permitted values for the various field types are as follows:

\begin{itemize}
\item \verb|DBF_STRING| \\
Any ASCII string. If it exceeds the field length, it will be truncated.

\item \verb|DBF_CHAR|, \verb|DBF_UCHAR|, \verb|DBF_SHORT|, \verb|DBF_USHORT|, \verb|DBF_LONG|, \verb|DBF_ULONG| \\
A string that represents a valid integer.
The standard C conventions are applied, i.e. a leading 0 means the value is given in octal and a leading 0x means that value is given in hex.

\item \verb|DBF_FLOAT|, \verb|DBF_DOUBLE| \\
The string must represent a valid floating point number.
Infinities or NaN are also allowed.

\item \verb|DBF_MENU| \\
The string must be one of the valid choices for the associated menu.

\item \verb|DBF_DEVICE| \\
The string must be one of the valid device choice strings.

\item \verb|DBF_INLINK|, \verb|DBF_OUTLINK|, \verb|DBF_FWDLINK| \\
NOTES:

\begin{itemize}
\item If the field name is \verb|INP| or \verb|OUT| then this field is associated with \verb|DTYP|, and the permitted values are determined by the link type of the device support selected by the current \verb|DTYP| choice string.
Other \verb|DBF_INLINK| and \verb|DBF_OUTLINK| fields must be either \verb|CONSTANT| or \verb|PV_LINK|s.

\item A device support that specifies a link type of \verb|CONSTANT| can be given either a constant or a \verb|PV_LINK|.
\end{itemize}

The allowed values for the field depend on the device support's link type as follows:

\begin{itemize}
\item \verb|CONSTANT| \\
\index{CONSTANT -- link field value}
A numeric literal, valid for the field type it is to be read into.

\item \verb|PV_LINK| \\
\index{PV\_LINK -- link field value}
A value of the form:

\begin{verbatim}
record.field process maximize
\end{verbatim}

\verb|record| is the name of a record that exists in this or another IOC.

The \verb|.field|, \verb|process|, and \verb|maximize| parts are all optional.

The default value for \verb|.field| is \verb|.VAL|.

\verb|process| can have one of the following values:

\begin{itemize}
\item \verb|NPP| -- No Process Passive (Default)
\item \verb|PP| -- Process Passive
\item \verb|CA| -- Force link to be a channel access link
\item \verb|CP| -- CA and process on monitor
\item \verb|CPP| -- CA and process on monitor if record is passive

NOTES:

\verb|CP| and \verb|CPP| are valid only for \verb|DBF_INLINK| fields.

\verb|DBF_FWDLINK| fields can use \verb|PP| or \verb|CA|.
If a \verb|DBF_FWDLINK| is a channel access link it must reference the target record's \verb|PROC| field.
\end{itemize}

\verb|maximize| can have one of the following values:

\begin{itemize}
\item \verb|NMS| -- No Maximize Severity (Default)
\item \verb|MS| -- Maximize Severity
\item \verb|MSS| -- Maximize Severity and Status
\item \verb|MSI| -- Maximize Severity if Invalid
\end{itemize}

\index{VME\_IO -- link field value}
\item \verb|VME_IO| \\
\verb|#Ccard Ssignal @parm|

\verb|card| -- the card number of associated hardware module \\
\verb|signal| -- signal on card \\
\verb|parm| -- An arbitrary character string of up to 31 characters. This field is optional and is device specific.

\item \verb|CAMAC_IO| \\
\index{CAMAC\_IO -- link field value}
\verb|#Bbranch Ccrate Nstation Asubaddress Ffunction @parm|

\verb|branch|, \verb|crate|, \verb|station|, \verb|subaddress|, and \verb|function| should be obvious to \verb|camac| users.
\verb|subaddress| and \verb|function| are optional (0 if not given).
\verb|parm| is also optional and is device specific (25 characters max).

\item \verb|AB_IO| \\
\index{AB\_IO -- link field value}
\verb|#Llink Aadapter Ccard Ssignal @parm|

\verb|link| -- Scanner, i.e. vme scanner number \\
\verb|adapter| -- Adapter. Allen Bradley also calls this rack \\
\verb|card| -- Card within Allen Bradley Chassis \\
\verb|signal| -- signal on card \\
\verb|parm| -- optional device-specific character string (27 char max)

\item \verb|GPIB_IO| \\
\index{GPIB\_IO -- link field value}
\verb|#Llink Aaddr @parm|

\verb|link| -- gpib link, i.e. interface \\
\verb|addr| -- GPIB address \\
\verb|parm| -- device-specific character string (31 char max)

\item \verb|BITBUS_IO| \\
\index{BITBUS\_IO -- link field value}
\verb|#Llink Nnode Pport Ssignal @parm|

\verb|link| -- link, i.e.  vme bitbus interface \\
\verb|node| -- bitbus node \\
\verb|port| -- port on the node \\
\verb|signal| -- signal on port \\
\verb|parm| -- device specific-character string (31 char max)

\item \verb|INST_IO|
\index{INST\_IO -- link field value}
\verb|@parm|

\verb|parm| -- Device dependent character string

\item \verb|BBGPIB_IO| \\
\index{BBGPIB\_IO -- link field value}
\verb|#Llink Bbbaddr Ggpibaddr @parm|

\verb|link| -- link, i.e. vme bitbus interface \\
\verb|bbadddr| -- bitbus address \\
\verb|gpibaddr| -- gpib address \\
\verb|parm| -- optional device-specific character string (31 char max)

\item \verb|RF_IO| \\
\index{RF\_IO -- link field value}
\verb|#Rcryo Mmicro Ddataset Eelement|

\item \verb|VXI_IO| \\
\index{VXI\_IO -- link field value}
\verb|#Vframe Cslot Ssignal @parm| (Dynamic addressing) \\
     or \\
\verb|#Vla Signal @parm|  (Static Addressing)

\verb|frame| -- VXI frame number \\
\verb|slot| -- Slot within VXI frame \\
\verb|la| -- Logical Address \\
\verb|signal| -- Signal Number \\
\verb|parm| -- device specific character string(25 char max)
\end{itemize}
\end{itemize}

\index{info\_name -- record instance definition}
\item [info\_name] The name of an Information Item related to this record.
See section \ref{Record Information Item} below for more on Information Items.

\index{info\_value -- record instance definition}
\item [info\_value] Any ASCII string.
IOC applications using this information item may place additional restrictions on the contents of the string.

\end{description}

\subsubsection{Examples}

\begin{verbatim}
record(ai,STS_AbAiMaS0) {
    field(SCAN,".1 second")
    field(DTYP,"AB-1771IFE-4to20MA")
    field(INP,"#L0 A2 C0 S0 F0 @")
    field(PREC,"4")
    field(LINR,"LINEAR")
    field(EGUF,"20")
    field(EGUL,"4")
    field(EGU,"MilliAmps")
    field(HOPR,"20")
    field(LOPR,"4")
}
record(ao,STS_AbAoMaC1S0) {
    field(DTYP,"AB-1771OFE")
    field(OUT,"#L0 A2 C1 S0 F0 @")
    field(LINR,"LINEAR")
    field(EGUF,"20")
    field(EGUL,"4")
    field(EGU,"MilliAmp")
    field(DRVH,"20")
    field(DRVL,"4")
    field(HOPR,"20")
    field(LOPR,"4")
    info(autosaveFields,"VAL")
}
record(bi,STS_AbDiA0C0S0) {
    field(SCAN,"I/O Intr")
    field(DTYP,"AB-Binary Input")
    field(INP,"#L0 A0 C0 S0 F0 @")
    field(ZNAM,"Off")
    field(ONAM,"On")
}
\end{verbatim}

\section{Record Information Item}
\label{Record Information Item}

\index{Information item}
Information items provide a way to attach named string values to individual record instances that are loaded at the same time as the record definition.
They can be attached to any record without having to modify the record type, and can be retrieved by programs running on the IOC (they are not visible via Channel Access at all).
Each item attached to a single record must have a unique name by which it is addressed, and database access provides routines to allow a record's info items to be scanned, searched for, retrieved and set.
At runtime a \verb|void*| \index{Infomation item pointer}pointer can also be associated with each item, although only the string value can be initialized from the record definition when the database is loaded.

\section{Record Attributes}

\index{record attribute}
Each record type can have any number of record attributes.
Each attribute is a \index{Psuedo field}psuedo field that can be accessed via database and channel access.
Each attribute has a name that acts like a field name but returns the same value for all instances of the record type.
Two attributes are generated automatically for each record type: \verb|RTYP| and \verb|VERS|.
The value for \verb|RTYP| is the record type name.
The default value for \verb|VERS| is ``none specified'', which can be changed by record support.
Record support can call the following routine to create new attributes or change existing attributes:

\index{dbPutAttribute}
\begin{lstlisting}[language=C]
long dbPutAttribute(char *rtype, char *name, char *value)
\end{lstlisting}

The arguments are:

\begin{description}
\item \verb|rtype| -- The name of recordtype.
\item \verb|name| -- The attribute name, i.e. the psuedo field name.
\item \verb|value| -- The value assigned to the attribute.
\end{description}

\section{Breakpoint Tables -- Discussion}

\index{Breakpoint Tables}
\index{menuConvert}
\index{LINR}
The menu \verb|menuConvert| is used for field \verb|LINR| of the \verb|ai| and \verb|ao| records.
These records allow raw data to be converted to/from engineering units via one of the following:

\begin{enumerate}
\item No Conversion.
\item \index{Slope Conversion}Slope Conversion.
\item \index{Linear Conversion}Linear Conversion.
\item Breakpoint table.
\end{enumerate}

Other record types can also use this feature.
The first choice specifies no conversion; the second and third are both linear conversions, the difference being that for Slope conversion the user specifies the conversion slope and offset values directly, whereas for Linear conversions these are calculated by the device support from the requested Engineering Units range and the device support's knowledge of the hardware conversion range.
The remaining choices are assumed to be the names of breakpoint tables.
If a breakpoint table is chosen, the record support modules calls \verb|cvtRawToEngBpt| or \verb|cvtEngToRawBpt|.
You can look at the \verb|ai| and \verb|ao| record support modules for details.

If a user wants to add additional breakpoint tables, then the following should be done:

\begin{itemize}
\item Copy the \verb|menuConvert.dbd| file from EPICS \verb|base/src/ioc/bpt|
\item Add definitions for new breakpoint tables to the end
\item Make sure modified \verb|menuConvert.dbd| is loaded  into the IOC instead of EPICS version.
\end{itemize}

It is only necessary to load a breakpoint file if a record instance actually chooses it.
It should also be mentioned that the Allen Bradley IXE device support misuses the \verb|LINR| field.
If you use this module, it is very important that you do not change any of the EPICS supplied definitions in \verb|menuConvert.dbd|.
Just add your definitions at the end.

If a breakpoint table is chosen, then the corresponding breakpoint file must be loaded into the IOC before \verb|iocInit| is called.

Normally, it is desirable to directly create the breakpoint tables.
However, sometimes it is desirable to create a breakpoint table from a table of raw values representing equally spaced engineering units.
A good example is the Thermocouple tables in the OMEGA Engineering, INC Temperature Measurement Handbook.
A tool \index{makeBpt}\verb|makeBpt| is provided to convert such data to a breakpoint table.

The format for generating a breakpoint table from a data table of raw values corresponding to equally spaced engineering values is:

\begin{verbatim}
!comment line
<header line>
<data table>
\end{verbatim}

The header line contains the following information:

\begin{description}
\item [Name] An alphanumeric ascii string specifying the breakpoint table name
\item [Low Value Eng] Engineering Units Value for first breakpoint table entry
\item [Low Value Raw] Raw value for first breakpoint table entry
\item [High Value Eng] Engineering Units: Highest Value desired
\item [High Value Raw] Raw Value for High Value Eng
\item [Error] Allowed error (Engineering Units)
\item [First Table] Engineering units corresponding to first data table entry
\item [Last Table] Engineering units corresponding to last data table entry
\item [Delta Table] Change in engineering units per data table entry
\end{description}

 An example definition is:

\begin{verbatim}
"TypeKdegF" 32 0 1832 4095 1.0 -454 2500 1
<data table>
\end{verbatim}

The breakpoint table can be generated by executing

\begin{verbatim}
makeBpt bptXXX.data
\end{verbatim}

The input file must have the extension of data.
The output filename is the same as the input filename with the extension of \verb|.dbd|.

Another way to create the breakpoint table is to include the following definition in a \verb|Makefile|:

\begin{verbatim}
BPTS += bptXXX.dbd
\end{verbatim}

NOTE: This requires the naming convention that all data tables are of the form \verb|bpt<name>.data| and a breakpoint table \verb|bpt<name>.dbd|.

\section{Menu and Record Type Include File Generation.}

\index{Include File Generation}
\subsection{Introduction}

\index{dbdToMenuH.pl}
\index{dbdToRecordtypeH.pl}
Given a file containing menu definitions, the program \verb|dbdToMenuH.pl| generates a C/C++ header file for use by code which needs those menus.
Given a file containing any combination of menu definitions and record type definitions, the program \verb|dbdToRecordtypeH.pl| generates a C/C++ header file for use by any code which needs those menus and record type.

EPICS Base uses the following conventions for managing menu and recordtype definitions.
Users generating local record types are encouraged to follow these.

\begin{itemize}
\item Each menu that is used by fields in database common (for example \verb|menuScan|) or is of global use (for example \verb|menuYesNo|) should be defined in its own file.
The name of the file is the same as the menu name, with an extension of \verb|.dbd|.
The name of the generated include file is the menu name, with an extension of \verb|.h|.
Thus \verb|menuScan| is defined in a file \verb|menuScan.dbd| and the generated include file is named \verb|menuScan.h|

\item Each record type is defined in its own file.
This file should also contain any menu definitions that are used only by that record type.
Menus that are specific to one particular record type should use that record type name as a prefix to the menu name.
The name of the file is the same as the record type, followed by \verb|Record.dbd|.
The name of the generated include file is the same as the \verb|.dbd| file but with an extension of \verb|.h|.
Thus the record type \verb|ao| is defined in a file \verb|aoRecord.dbd| and the generated include file is named \verb|aoRecord.h|.
Since \verb|aoRecord| has a private menu called \verb|aoOIF|, the \verb|dbd| file and the generated include file will have definitions for this menu.
Thus for each record type, there are two source files (\verb|xxxRecord.dbd| and \verb|xxxRecord.c|) and one generated file (\verb|xxxRecord.h|).
\end{itemize}

Note that developers don't normally execute the \verb|dbdToMenuH.pl| or \verb|dbdToRecordtypeH.pl| programs manually.
If the proper naming conventions are used, it is only necessary to add definitions to the appropriate \verb|Makefile|.
Consult the chapter on the EPICS Build Facility for details.

\subsection{dbdToMenuH.pl}

\index{dbdToMenuH.pl}
This tool is executed as follows:

\begin{verbatim}
dbdToMenuH.pl [-D] [-I dir] [-o menu.h] menu.dbd [menu.h]
\end{verbatim}

It reads in the input file \verb|menu.dbd| and generates a C/C++ header file containing enumerated type definitions for the menus found in the input file.

Multiple \verb|-I| options can be provided to specify directories that must be searched when looking for included files.
If no output filename is specified with the \verb|-o menu.h| option or as a final command-line parameter, then the output filename will be constructed from the input filename, replacing \verb|.dbd| with \verb|.h|.

The \verb|-D| option causes the program to output Makefile dependency information for the output file to standard output, instead of actually performing the functions describe above.

For example \verb|menuPriority.dbd|, which contains the definitions for processing priority contains:

\begin{verbatim}
menu(menuPriority) {
    choice(menuPriorityLOW,"LOW")
    choice(menuPriorityMEDIUM,"MEDIUM")
    choice(menuPriorityHIGH,"HIGH")
}
\end{verbatim}

The include file \verb|menuPriority.h| that is generated contains:

\begin{lstlisting}[language=C]
/* menuPriority.h generated from menuPriority.dbd */

#ifndef INC_menuPriority_H
#define INC_menuPriority_H

typedef enum {
    menuPriorityLOW                 /* LOW */,
    menuPriorityMEDIUM              /* MEDIUM */,
    menuPriorityHIGH                /* HIGH */,
    menuPriority_NUM_CHOICES
} menuPriority;

#endif /* INC_menuPriority_H */
\end{lstlisting}

Any code that needs the priority menu values should include this file and make use of these definitions.

\subsection{dbdToRecordtypeH.pl}

\index{dbdToRecordtypeH.pl}
This tool is executed as follows:

\begin{verbatim}
dbdTorecordtypeH.pl [-D] [-I dir] [-o xRecord.h] xRecord.dbd [xRecord.h]
\end{verbatim}

It reads in the input file \verb|xRecord.dhd| and generates a C/C++ header file which defines the in-memory structure of the given record type and provides other associated information for the compiler.
If the input file contains any menu definitions, they will also be converted into enumerated type definitions in the output file.

Multiple \verb|-I| options can be provided to specify directories that must be searched when looking for included files.
If no output filename is specified with the \verb|-o xRecord.h| option or as a final command-line parameter then the output filename will be constructed from the input filename, replacing \verb|.dbd| with \verb|.h|.

The \verb|-D| option causes the program to output Makefile dependency information for the output file to standard output, instead of actually performing the functions describe above.

For example \verb|aoRecord.dbd|, which contains the definitions for the analog output record contains:

\begin{verbatim}
menu(aoOIF) {
    choice(aoOIF_Full,"Full")
    choice(aoOIF_Incremental,"Incremental")
}
recordtype(ao) {
    include "dbCommon.dbd" 
    field(VAL,DBF_DOUBLE) {
        prompt("Desired Output")
        promptgroup(GUI_OUTPUT)
        asl(ASL0)
        pp(TRUE)
    }
    field(OVAL,DBF_DOUBLE) {
        prompt("Output Value")
    }
    ... /* many more field definitions */
}
\end{verbatim}

The include file \verb|aoRecord.h| that is generated contains:

\begin{lstlisting}[language=C]
/* aoRecord.h generated from aoRecord.dbd */

#ifndef INC_aoRecord_H
#define INC_aoRecord_H

#include "epicsTypes.h"
#include "link.h"
#include "epicsMutex.h"
#include "ellLib.h"
#include "epicsTime.h"

typedef enum {
    aoOIF_Full                      /* Full */,
    aoOIF_Incremental               /* Incremental */,
    aoOIF_NUM_CHOICES
} aoOIF;

typedef struct aoRecord {
    char                name[61];   /* Record Name */
    ... /* define remaining fields from database common */
    epicsFloat64        val;        /* Desired Output */
    epicsFloat64        oval;       /* Output Value */
    ... /* define remaining record specific fields */
} aoRecord;

typedef enum {
    aoRecordNAME = 0,
    aoRecordDESC = 1,
    ... /* indices for remaining fields in database common */
    aoRecordVAL = 43,
    aoRecordOVAL = 44,
    ... /* indices for remaining record specific fields */
} aoFieldIndex;

#ifdef GEN_SIZE_OFFSET

#ifdef __cplusplus
extern "C" {
#endif
#include <epicsExport.h>
static int aoRecordSizeOffset(dbRecordType *prt)
{
    aoRecord *prec = 0;
    prt->papFldDes[aoRecordNAME]->size = sizeof(prec->name);
    ... /* code to compute size for remaining fields */
    prt->papFldDes[aoRecordNAME]->offset = (char *)&prec->name - (char *)prec;
    ... /* code to compute offset for remaining fields */
    prt->rec_size = sizeof(*prec);
    return 0;
}
epicsExportRegistrar(aoRecordSizeOffset);

#ifdef __cplusplus
}
#endif
#endif /* GEN_SIZE_OFFSET */

#endif /* INC_aoRecord_H */
\end{lstlisting}

The analog output record support module and all associated device support modules should include this file.
No other code should use it.

Let's discuss the various parts of the file:

\begin{itemize}
\item The \verb|enum| generated from the menu definition should be used to provide values for the field associated with that menu.

\item The \verb|typedef struct| defining the record are used by record support and device support to access the fields in an analog output record.

\item The next \verb|enum| defines an index number for each field within the record.
This is useful for the record support routines that are passed a pointer to a \verb|DBADDR| structure.
They can have code like the following:

\end{itemize}

\begin{lstlisting}[language=C]
switch (dbGetFieldIndex(pdbAddr)) {
    case aoRecordVAL :
        ...
        break;
    case aoRecordXXX:
        ...
        break;
    default:
        ...
}
\end{lstlisting}

The generated routine \verb|aoRecordSizeOffset| is executed when the record type gets registered with an IOC.
The routine is compiled with the record type code, and is marked static so it will not be visible outside of that file.
The associate record support source code MUST include the generated header file only after defining the \verb|GEN_SIZE_OFFSET| macro like this:

\begin{lstlisting}[language=C]
#define GEN_SIZE_OFFSET
#include "aoRecord.h"
#undef GEN_SIZE_OFFSET
\end{lstlisting}

This convention ensures that the routine is defined exactly once.
The \verb|epicsExportRegistrar| statement ensures that the record registration code can find and call the routine.

\section{dbdExpand.pl}

\index{dbdExpand.pl}
\begin{verbatim}
dbdExpand.pl [-D] [-I dir] [-S mac=sub] [-o out.dbd] in.dbd ...
\end{verbatim}

This program reads and combines the database definition from all the input files, then writes a single output file containing all information from the 
input files.
The output content differs from the input in that comment lines are removed, and all defined macros and include files are expanded.
Unlike the previous \verb|dbExpand| program, this program does not understand database instances and cannot be used with \verb|.db| or \verb|.vdb| files.

Multiple \verb|-I| options can be provided to specify directories that must be searched when looking for included files.
Multiple \verb|-S| options are allowed for macro substitution, or multiple macros can be specified within a single option.
If no output filename is specified with the \verb|-o out.dbd| option then the output will go to stdout.

The \verb|-D| option causes the program to output Makefile dependency information for the output file to standard output, instead of actually performing the functions describe above.

\section{dbLoadDatabase}

\index{dbLoadDatabase}
\begin{lstlisting}[language=C]
int dbLoadDatabase(char *dbdfile, char *path, char *substitutions);
\end{lstlisting}

This IOC command loads a database file which may contain any of the Database Definitions described in this chapter.
The \verb|dbdfile| string may contain environment variable macros of the form \verb|${MOTOR}| which will be expanded before the file is opened.
Both the \verb|path| and \verb|substitutions| parameters can be null or empty, and are usually ommitted.
Note that \verb|dbLoadDatabase| should only used to load Database Definition (\verb|.dbd|) files, although it is currently possible to use it for loading Record Instance (\verb|.db|) files as well.

As each line of the file is read, the substitutions specified in \verb|substitutions| are performed. Substitutions are specified as follows:

\begin{verbatim}
"var1=sub1,var2=sub3,..."
\end{verbatim}

Variables are used in the file with the syntax \verb|$(var)| or \verb|${var}|.
If the substitution string

\begin{verbatim}
"a=1,b=2,c=\"this is a test\""
\end{verbatim}

were used, any variables \verb|$(a)|, \verb|$(b)|, \verb|$(c)| in the database file would have the appropriate values substituted during parsing.

\section{dbLoadRecords}

\index{dbLoadRecords}
\begin{lstlisting}[language=C]
int dbLoadRecords(char* dbfile, char* substitutions);
\end{lstlisting}

This IOC command loads a file containing record instances, record aliases and/or breakpoint tables.
The \verb|dbfile| string may contain environment variable macros of the form \verb|${MOTOR}| which will be expanded before the file is opened.
The \verb|substitutions| parameter can be null or empty, and is often ommitted.
Note that \verb|dbLoadRecords| should only used to load Record Instance (\verb|.db|) files, although it is currently possible to use it for loading Database Definition (\verb|.dbd|) files as well.

\subsection{Example}

For example, let the file \verb|test.db| contain:

\begin{verbatim}
record(ai, "$(pre)testrec1")
record(ai, "$(pre)testrec2")
record(stringout, "$(pre)testrec3") {
    field(VAL, "$(STR)")
    field(SCAN, "$(SCAN)")
}
\end{verbatim}

Then issuing the command:

\begin{verbatim}
dbLoadRecords("test.db", "pre=TEST,STR=test,SCAN=Passive")
\end{verbatim}

gives the same results as loading:

\begin{verbatim}
record(ai, "TESTtestrec1")
record(ai, "TESTtestrec2")
record(stringout, "TESTtestrec3") {
    field(VAL, "test")
    field(SCAN, "Passive")
}
\end{verbatim}

\section{dbLoadTemplate}

\index{dbLoadTemplate}
\begin{lstlisting}[language=C]
int dbLoadTemplate(char *subfile, char *substitutions);
\end{lstlisting}

This IOC command reads a template substitutions file which provides instructions for loading database instance files and gives values for the \verb|$(xxx)| macros they may contain.
This command performs those substitutions while loading the database instances requested.

The \verb|subfile| parameter gives the name of the template substitution file to be used.
The optional \verb|substitutions| parameter may contain additional global macro values, which can be overridden by values given within the substitution file.

\index{MSI}
The MSI program can be used to expand templates at build-time instead of using this command at run-time; both understand the same substitution file syntax.

\subsection{Template File Syntax}

\index{template substitution}
\index{substitution file}
The template substitution file syntax is described in the following Extended Backus-Naur Form grammar:

\begin{verbatim}
substitution-file ::= ( global-defs | template-subs )+

global-defs ::= 'global' '{' variable-defs? '}'

template-subs ::= template-filename '{' subs? '}'
template-filename ::= 'file' file-name
subs ::= pattern-subs | variable-subs

pattern-subs ::= 'pattern' '{' pattern-names? '}' pattern-defs?
pattern-names ::= ( variable-name ','? )+
pattern-defs ::= ( global-defs | ( '{' pattern-values? '}' ) )+
pattern-values ::= ( value ','? )+

variable-subs ::= ( global-defs | ( '{' variable-defs? '}' ) )+
variable-defs ::= ( variable-def ','? )+
variable-def ::= variable-name '=' value

variable-name ::= variable-name-start variable-name-char*
file-name ::= file-name-char+ | double-quoted-str | single-quoted-str
value ::= value-char+ | double-quoted-str | single-quoted-str

double-quoted-str ::= '"' (double-quoted-char | escaped-char)* '"'
single-quoted-str ::= "'" (single-quoted-char | escaped-char)* "'"
double-quoted-char ::= [^"\]
single-quoted-char ::= [^'\]
escaped-char ::= '\' .

value-char ::= [a-zA-Z0-9_+:;./\<>[] | '-' | ']'
variable-name-start ::= [a-zA-Z_]
variable-name-char ::= [a-zA-Z0-9_]
file-name-char ::= [a-zA-Z0-9_+:;./\] | '-'
\end{verbatim}

Note that the current implementation may accept a wider range of characters for the last three definitions than those listed here, but future releases may restrict the characters to those given above.

Any record instance file names must appear inside quotation marks if the name contains any environment variable macros of the form \verb|${ENV_VAR_NAME}|, which will be expanded before the named file is opened.

\subsection{Template File Formats}

Two different template formats are supported by the syntax rules given above.
The format is either:

\begin{verbatim}
file name.template {
    { var1=sub1_for_set1, var2=sub2_for_set1, var3=sub3_for_set1, ... }
    { var1=sub1_for_set2, var2=sub2_for_set2, var3=sub3_for_set2, ... }
    { var1=sub1_for_set3, var2=sub2_for_set3, var3=sub3_for_set3, ... }
}
\end{verbatim}

or:

\begin{verbatim}
file name.template {
pattern { var1, var2, var3, ... }
    { sub1_for_set1, sub2_for_set1, sub3_for_set1, ... }
    { sub1_for_set2, sub2_for_set2, sub3_for_set2, ... }
    { sub1_for_set3, sub2_for_set3, sub3_for_set3, ... }
}
\end{verbatim}

The first line (\verb|file name.template|) specifies the record instance input file. The file name may appear inside double
quotation marks; these are required if the name contains any characters that are not in the following set, or if it contains
environment variable macros of the form \verb|${VAR_NAME}| which must be expanded to generate the file name:

\begin{verbatim}
a-z A-Z 0-9 _ + - . / \ : ; [ ] < >
\end{verbatim}

Each set of definitions enclosed in \verb|{}| is variable substitution for the input file. The input file has each set applied to it to
produce one composite file with all the completed substitutions in it. Version 1 should be obvious. In version 2, the
variables are listed in the \verb|pattern{}| line, which must precede the braced substitution lines. The braced substitution
lines contains sets which match up with the \verb|pattern{}| line.

\subsection{Example}

Two simple template file examples are shown below. The examples specify the same substitutions to perform: 
\verb|this=sub1| and \verb|that=sub2| for a first set, and \verb|this=sub3| and \verb|that=sub4| for a second set. 

\begin{verbatim}
file test.template {
    { this=sub1,that=sub2 }
    { this=sub3,that=sub4 }
}

file test.template {
    pattern{this,that}
    {sub1,sub2}
    {sub3,sub4 }
}
\end{verbatim}

Assume that the file \verb|test.template| contains:

\begin{verbatim}
record(ai,"$(this)record") {
    field(DESC,"this = $(this)")
}
record(ai,"$(that)record") {
    field(DESC,"this = $(that)")
}
\end{verbatim}

Using \verb|dbLoadTemplate| with either input is the same as defining the records:

\begin{verbatim}
record(ai,"sub1record") {
    field(DESC,"this = sub1")
}
record(ai,"sub2record") {
    field(DESC,"this = sub2")
}

record(ai,"sub3record") {
    field(DESC,"this = sub3")
}
record(ai,"sub4record") {
    field(DESC,"this = sub4")
}
\end{verbatim}
