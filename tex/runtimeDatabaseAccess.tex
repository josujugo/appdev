\chapter{Runtime Database Access}\index{Runtime Database Access}

\section{Overview}

This chapter describes routines for manipulating and accessing an initialized IOC database.

This chapter is divided into the following sections:

\begin{itemize}
\item Database related include files.
All of interest are listed and those of general interest are discussed briefly.

\item Runtime database access overview.

\item Description of each runtime database access routine.

\item Runtime modification of link fields.

\item Lock Set Routines

\item Database to Channel Access Routines

\end{itemize}

\section{Database Include Files}

There are a number of database related include files.
Of particular interest to this chapter are:

\begin{itemize}
\item \index{dbDefs.h}dbDefs.h: Miscellaneous database related definitions

\item \index{dbFldTypes.h}dbFldTypes.h: Field type definitions

\item \index{dbAccess.h}dbAccess.h: Runtime database access definitions.

\item \index{link.h}link.h: Definitions for link fields.

\end{itemize}

\subsection{dbDefs.h}

\index{dbDefs.h}
This file contains a number of database related definitions.
The most important are:

\begin{itemize}
\item \index{PVNAME\_STRINGSZ}PVNAME\_STRINGSZ: The number of characters reserved for the record name, including the terminating zero byte.

\item \index{PVNAME\_SZ}PVNAME\_SZ: The maximum number of characters allowed in the record name.

\item \index{DB\_MAX\_CHOICES}DB\_MAX\_CHOICES: The maximum number of choices for a choice field.

\end{itemize}

Note that \verb|DB_MAX_CHOICES| applies for code using the runtime routines documented in this chapter, but for Channel Access clients the maximum number of choices and their choice string length are different, and are defined in the db\_access.h file.

\subsection{dbFldTypes.h}

\index{dbFldTypes.h}
This file defines the possible field types.
A field's type is perhaps its most important attribute.
Changing the possible field types is a fundamental change to the IOC software, because many IOC software components are aware of the field types.

The field types are:

\begin{itemize}
\item \index{DBF\_STRING}DBF\_STRING: 40 character ASCII string

\item \index{DBF\_CHAR}DBF\_CHAR: Signed character

\item \index{DBF\_UCHAR}DBF\_UCHAR: Unsigned character

\item \index{DBF\_SHORT}DBF\_SHORT: Short integer

\item \index{DBF\_USHORT}DBF\_USHORT: Unsigned short integer

\item \index{DBF\_LONG}DBF\_LONG: Long integer

\item \index{DBF\_ULONG}DBF\_ULONG: Unsigned long integer

\item \index{DBF\_FLOAT}DBF\_FLOAT: Floating point number

\item \index{DBF\_DOUBLE}DBF\_DOUBLE: Double precision float

\item \index{DBF\_ENUM}DBF\_ENUM: An enumerated field

\item \index{DBF\_MENU}DBF\_MENU: A menu choice field

\item \index{DBF\_DEVICE}DBF\_DEVICE: A device choice field

\item \index{DBF\_INLINK}DBF\_INLINK: Input Link

\item \index{DBF\_OUTLINK}DBF\_OUTLINK: Output Link

\item \index{DBF\_FWDLINK}DBF\_FWDLINK: Forward Link

\item \index{DBF\_NOACCESS}DBF\_NOACCESS: A private field for use by record access routines

\end{itemize}

A field of type \verb|DBF_STRING|, ..., \verb|DBF_DOUBLE| can be a scalar or an array.
A \verb|DBF_STRING| field contains a \verb|NULL| terminated ascii string.
The field types \verb|DBF_CHAR|, ..., \verb|DBF_DOUBLE| correspond to the standard C data types.

\verb|DBF_ENUM| is used for enumerated items, which is analogous to the C language enumeration.
An example of an enum field is field \verb|VAL| of a multi bit binary record.

The field types \verb|DBF_ENUM|, \verb|DBF_MENU|, and \verb|DBF_DEVICE| all have an associated set of ASCII strings defining the choices.
For a \verb|DBF_ENUM|, the record support module supplies values and thus are not available for static database access.
The database access routines locate the choice strings for the other types.

\verb|DBF_INLINK| and \verb|DBF_OUTLINK| specify link fields.
A link field can refer to a signal located in a hardware module, to a field located in a database record in the same IOC, or to a field located in a record in another IOC.
A \verb|DBF_FWDLINK| can only refer to a record in the same IOC.
Link fields are described in a later chapter.

\verb|DBF_INLINK| (input), \verb|DBF_OUTLINK| (output), and \verb|DBF_FWDLINK| (forward) specify that the field is a link structure as defined in \verb|link.h|.
There are three classes of links:

\begin{enumerate}
\item Constant - The value associated with the field is a floating point value initialized with a constant value.
This is somewhat of a misnomer because constant link fields can be modified via \verb|dbPutField| or \verb|dbPutLink|.

\item Hardware links - The link contains a data structure which describes a signal connected to a particular hardware bus.
See \verb|link.h| for a description of the bus types currently supported.

\item Process Variable Links - This is one of three types:

\begin{enumerate}

\item PV\_LINK: The process variable name.

\item DB\_LINK: A reference to a process variable in the same IOC.

\item CA\_LINK: A reference to a variable located in another IOC.

\end{enumerate}

\end{enumerate}

When first loaded the field is always creates as a \verb|PV_LINK|.
When the IOC is initialized each \verb|PV_LINK| is converted either to a \verb|DB_LINK| or a \verb|CA_LINK|.

\verb|DBF_NOACCESS| fields are for private use by record processing routines.

\subsection{dbAccess.h}

This file is the interface definition for the run time database access library, i.e. for the routines described in this chapter.

An important structure defined in this header file is \verb|DBADDR|

\begin{verbatim}
typedef struct dbAddr{
    struct dbCommon *precord;/* address of record*/
    void* pfield;/* address of field*/
    void* pfldDes;/* address of struct fldDes*/
    void* asPvt;/* Access Security Private*/
    long  no_elements; /* number of elements (arrays)*/
    short field_type;/* type of database field*/
    short field_size;/* size (bytes) of the field*/
    short special;/* special processing*/
    short dbr_field_type; /*optimal database request type*/
}DBADDR;
\end{verbatim}
\index{struct dbAddr}
\index{dbAdd}
\index{DBADDR}
\begin{itemize}
\item \index{precord - DBADDR}precord: Address of record.
Note that its type is a pointer to a structure defining the fields common to all record types.
The common fields appear at the beginning of each record.
A record support module can cast \verb|precord| to point to the specific record type.

\item \index{pfield in DBADDR}pfield: Address of the field within the record.
Note that \verb|pfield| provides direct access to the data value.

\item \index{pfldDes in DBADDR}pfldDes: This points to a structure containing all details concerning the field.
See Chapter ``Database Structures" for details.

\item \index{asPvt in DBADDR}asPvt: A field used by access security.

\item \index{no\_elements in DBADDR}no\_elements: A string or numeric field can be either a scalar or an array.
For scalar fields \verb|no_elements| has the value 1.
For array fields it is the maximum number of elements that can be stored in the array.

\item \index{field\_type in DBADDR}field\_type: Field type.

\item \index{field\_size in DBADDR}field\_size: Size of one element of the field.

\item \index{special in DBADDR}special: Some fields require special processing.
This specifies the type.
Special processing is described later in this manual.

\item \index{dbr\_field\_type in DBADDR}dbr\_field\_type: This specifies the optimal database request type for this field, i.e. the request type that will require the least CPU overhead.

\end{itemize}

NOTE: \verb|pfield|, \verb|no_elements|, \verb|field_type|, \verb|field_size|, \verb|special|, and \verb|dbr_field_type| can all be set by 
record support (\verb|cvt_dbaddr|).
Thus \verb|field_type|, \verb|field_size|, and \verb|special| can differ from that specified by \verb|pfldDes|.

\subsection{link.h }

This header file describes the various types of link fields supported by EPICS.

\section{Runtime Database Access Overview}

With the exception of record and device support, all access to the database is via the channel or database access routines.
Even record support routines access other records only via database or channel access.
Channel Access, in turn, accesses the database via database access.

Perhaps the easiest way to describe the database access layer is to list and briefly describe the set of routines that constitute database access.
This provides a good look at the facilities provided by the database.

Before describing database access, one caution must be mentioned.
The only way to communicate with an IOC database from outside the IOC is via Channel Access.
In addition, any special purpose software, i.e. any software not described in 
this document, should communicate with the database via Channel Access, not database access, even if it resides in the same IOC as the database.
Since Channel Access provides network independent access to a database, it must ultimately call database access routines.
The database access interface was changed in 1991, but Channel Access was never changed to use the new interface.
Instead a module was written which translates old style database access calls to new.
This interface between the old and new style database access calls is not discussed in this manual.

The \index{database access routines - List of}database access routines are:

\begin{itemize}
\item dbNameToAddr: Locate a database variable.

\item dbGetField: Get values associated with a database variable.

\item dbGetLink: Get value of field referenced by database link (Macro)

\item dbGetLinkValue: Get value of field referenced by database link (Subroutine)

\item dbGet: Routine called by \verb|dbGetLinkValue| and \verb|dbGetField|

\item dbPutField: Change the value of a database variable.

\item dbPutLink: Change value referenced by database link (Macro)

\item dbPutLinkValue: Change value referenced by database link (Subroutine)

\item dbPut: Routine called by \verb|dbPutxxx| functions.

\item dbProcessNotify: Process a record and request notification on completion, together with optional pre-process put or post-process get.

\item dbNotifyCancel: Cancell a dbProcessNotify.

\item dbBufferSize: Determine number of bytes in request buffer.

\item dbValueSize: Number of bytes for a value field.

\item dbGetRset: Get pointer to Record Support Entry Table

\item dbIsValueField: Is this field the VAL field.

\item dbGetFieldIndex: Get field index.
The first field in a record has index 0.

\item dbGetNelement: Get number of elements in the field

\item dbIsLinkConnected: Is the link field connected.

\item dbGetPdbAddrFromLink: Get address of DBADDR.

\item dbGetLinkDBFtype: Get field type of link.

\item dbGetControlLimits: Get Control Limits.

\item dbGetGraphicLimits: Get Graphic Limits.

\item dbGetAlarmLimits: Get Alarm Limits

\item dbGetPrecision: Get Precision

\item dbGetUnits: Get Units

\item dbGetNelements: Get Number of Elements

\item dbGetSevr: Get Severity

\item dbGetTimeStamp: Get Time Stamp

\item dbPutAttribute Give a value to a record attribute.

\item dbScanPassive: Process record if it is passive.

\item dbScanLink: Process record referenced by link if it is passive.

\item dbProcess: Process Record

\item dbScanFwdLink: Scan a forward link.

\end{itemize}

\subsection{Database Request Types and Options}

Before describing database access structures, it is necessary to describe database request types and request options.
When \verb|dbPutField| or \verb|dbGetField| are called one of the arguments is a database request type.
This argument has one of the following values: 

\begin{itemize}
\item \index{DBR\_STRING}DBR\_STRING: Value is a \verb|NULL| terminated string

\item \index{DBR\_CHAR}DBR\_CHAR: Value is a signed char

\item \index{DBR\_UCHAR}DBR\_UCHAR: Value is an unsigned char

\item \index{DBR\_SHORT}DBR\_SHORT: Value is a short integer

\item \index{DBR\_USHORT}DBR\_USHORT: Value is an unsigned short integer

\item \index{DBR\_LONG}DBR\_LONG: Value is a long integer

\item \index{DBR\_ULONG}DBR\_ULONG: Value is an unsigned long integer

\item \index{DBR\_FLOAT}DBR\_FLOAT: Value is an IEEE floating point value

\item \index{DBR\_DOUBLE}DBR\_DOUBLE: Value is an IEEE double precision floating point value

\item \index{DBR\_ENUM}DBR\_ENUM: Value is a short which is the enum item

\item \index{DBR\_PUT\_ACKT}DBR\_PUT\_ACKT: Value is an unsigned short for setting the \verb|ACKT|.

\item \index{DBR\_PUT\_ACKS}DBR\_PUT\_ACKS: Value is an unsigned short for global alarm acknowledgment.

\end{itemize}

The request types \verb|DBR_STRING|,..., \verb|DBR_DOUBLE| correspond exactly to valid data types for database fields.
\verb|DBR_ENUM| corresponds to database fields that represent a set of choices or options.
In particular it corresponds to the fields types \verb|DBF_ENUM|, \verb|DBF_DEVICE|, and \verb|DBF_MENU|.
The complete set of database field types are defined in \verb|dbFldTypes.h|.
\verb|DBR_PUT_ACKT| and \verb|DBR_PUT_ACKS| are used to perform global alarm acknowledgment.

\verb|dbGetField| also accepts argument options which is a mask containing a bit for each additional type of information the caller desires.
The complete set of options is:

\begin{itemize}
\item \index{DBR\_STATUS}DBR\_STATUS: returns the alarm status and severity

\item \index{DBR\_UNITS}DBR\_UNITS: returns a string specifying the engineering units

\item \index{DBR\_PRECISION}DBR\_PRECISION: returns a long integer specifying floating point precision.

\item \index{DBR\_TIME}DBR\_TIME: returns the time

\item \index{DBR\_ENUM\_STRS}DBR\_ENUM\_STRS: returns an array of strings

\item \index{DBR\_GR\_LONG}DBR\_GR\_LONG: returns graphics info as long values

\item \index{DBR\_GR\_DOUBLE}DBR\_GR\_DOUBLE: returns graphics info as double values

\item \index{DBR\_CTRL\_LONG}DBR\_CTRL\_LONG: returns control info as long values

\item \index{DBR\_CTRL\_DOUBLE}DBR\_CTRL\_DOUBLE: returns control info as double values

\item \index{DBR\_AL\_LONG}DBR\_AL\_LONG: returns alarm info as long values

\item \index{DBR\_AL\_DOUBLE}DBR\_AL\_DOUBLE: returns alarm info as double values

\end{itemize}

\subsection{Options}

Example

The file \verb|dbAccess.h| contains macros for using options.
A brief example should show how they are used.
The following example defines a buffer to accept an array of up to ten float values.
In addition it contains fields for options \verb|DBR_STATUS| and \verb|DBR_TIME|.

\begin{verbatim}
struct buffer {
    DBRstatus
    DBRtime
    float  value[10];
} buffer;
\end{verbatim}

The associated \verb|dbGetField| call is:

\begin{verbatim}
long options,number_elements,status;
    ...
options = DBR_STATUS | DBR_TIME;
number_elements = 10;
status = dbGetField(paddr,DBR_FLOAT,&buffer,&options,&number_elements);
\end{verbatim}

Consult \verb|dbAccess.h| for a complete list of macros.

Structure \verb|dbAddr| contains a field \verb|dbr_field_type|.
This field is the database request type that most closely matches the database field type.
Using this request type will put the smallest load on the IOC.

Channel Access provides routines similar to \verb|dbGetField|, and \verb|dbPutField|.
It provides remote access to \verb|dbGetField|, \verb|dbPutField|, and to the database monitors described below.

\subsection{ACKT and ACKS}

\index{DBR\_PUT\_ACKT}
\index{DBR\_PUT\_ACKS}
The request types \verb|DBR_PUT_ACKT| and \verb|DBR_PUT_ACKS| are used for global alarm acknowledgment.
The alarm handler uses these requests.
For each of these types the user (normally channel access) passes an unsigned short value.
This value represents:

\begin{description}

\item[DBR\_PUT\_ACKT] \index{DBR\_PUT\_ACKT} - Do transient alarms have to be acknowledged? 0 means no, 1 means yes

\item[DBR\_PUT\_ACKS] - The highest alarm severity to acknowledge.
If the current alarm severity is less then or equal to this value the alarm is acknowledged.

\end{description}

\section{Database Access Routines}

\subsection{dbNameToAddr}

\index{dbNameToAddr}
Locate a process variable, format:

\begin{verbatim}
long dbNameToAddr(
    char  *pname, /*ptr to process variable name */
    struct dbAddr  *paddr);
\end{verbatim}

\index{dbNameToAddr}The most important goal of database access can be stated simply:
Provide quick access to database records and fields within records.
The basic rules are:

\begin{enumerate}

\item Call \verb|dbNameToAddr| once and only once for each field to be accessed.

\item Read field values via \verb|dbGetField| and write values via \verb|dbPutField|.

\end{enumerate}

The routines described in this subsection are used by channel access, sequence programs, etc.
Record processing routines, however, use the routines described in the next section rather then \verb|dbGetField| and \verb|dbPutField|.

Given a process variable name, this routine locates the process variable and fills in the fields of structure \verb|dbAddr|.
The format for an IOC process variable name is one of:

\begin{verbatim}
<record_name>
<record_name>.
<record_name>.<field_name>
<record_name>.<field_name><modifier>
<record_name>.<modifier>
\end{verbatim}

For example the value field of a record with record named \verb|sample_name| is:

       ``\verb|sample_name.VAL|".

The \emph{record\_name} is case sensitive.
The \emph{field\_name}s available depend on the record type of the record and usually consist of all upper-case letters.
If omitted the field name \verb|VAL| is used if it exists.
Currently the only \emph{modifier} supported is a single dollar sign \verb|$| and is only valid on fields which are strings or links.
Additional modifiers may be added in future releases.

\verb|dbNameToAddr| locates a record via a process variable directory (PVD).
It fills in a structure (\verb|dbAddr|) describing the field.
\verb|dbAddr| contains the address of the record and also the field.
Thus other routines can locate the record and field without a search.
Although the PVD allows the record to be located via a hash algorithm and the field within a record via a binary search, it still takes about 80 microseconds (25MHz 68040) to located a process variable.
Once located the \verb|dbAddr| structure allows the process variable to be accessed directly.

\subsection{Get Routines}

\subsubsection{dbGetField}

Get values associated with a process variable, format:

\begin{verbatim}
long dbGetField(
    struct dbAddr *paddr,
    short dbrType,   /* DBR_xxx */
    void *pbuffer,   /* ptr to returned data */
    long *options,   /* ptr to options */
    long *nRequest,  /* ptr to number of elements */
    void *pfl);      /* used by monitor routines */
\end{verbatim}

\index{dbGetField}This routine locks, calls \verb|dbGet|, and unlocks.

\subsubsection{dbGetLink and dbGetLinkValue}

Get value from the field referenced by a database link, format:

\begin{verbatim}
long dbGetLink(
    struct db_link *plink, /* ptr to link field */
    short dbrType,         /* DBR_xxx */
    void *pbuffer,         /* ptr to returned data */
    long *options,         /* ptr to options */
    long *nRequest);       /* ptr to number of elements desired */
\end{verbatim}

\index{dbGetLink}
\index{dbGetLink}
NOTES:

\begin{itemize}

\item \verb|options| can be NULL if no options are desired.

\item \verb|nRequest| can be NULL for a scalar.

\end{itemize}

\verb|dbGetLink| is implemented as a macro that calls \verb|dbGetLinkValue| and can reference its arguments more than once.
The macro skips the call for constant links.
User code should never call \verb|dbGetLinkValue|.

This routine is called by database access itself and by record support and/or device support routines in order to get values for input links.
The value can be obtained directly from other records or via a channel access client.
This routine honors the link options (process and maximize severity).
In addition it has code that optimizes the case of no options and scalar.

\subsubsection{dbGet}

Get values associated with a process variable, format:

\begin{verbatim}
long dbGet(
    struct dbAddr *paddr,
    short dbrType,  /* DBR_xxx */
    void *pbuffer,  /* ptr to returned data */
    long *options,  /* ptr to options */
    long *nRequest, /* ptr to number of elements */
    void *pfl);     /* used by monitor routines */
\end{verbatim}

\index{dbGet}This routine retrieves the data referenced by \verb|paddr| and converts it to the format specified by \verb|dbrType|.

\begin{itemize}
\item \verb|options| is a read/write field.
Upon entry to \verb|dbGet|, \verb|options| specifies the desired options.
When \verb|dbGetField| returns, \verb|options| specifies the options actually honored.
If an option is not honored, the corresponding fields in buffer are filled with zeros.

\item \verb|nRequest| is also a read/write field.
Upon entry to \verb|dbGet| it specifies the maximum number of data elements the 
caller is willing to receive.
When \verb|dbGet| returns it has been set to the actual number of elements returned.
It is permissible to request zero elements.
This is useful when only option data is desired.

\item The \verb|pfl| argument is for use by the Channel Access monitor routines.
All other users must give \verb|pfl=NULL|.

\end{itemize}

\verb|dbGet| calls one of a number of conversion routines in order to convert data from the \verb|DBF| types to the \verb|DBR| types.
It calls record support routines for special cases such as arrays.
For example, if the number of field elements is greater then 1 and record support routine \verb|get_array_info| exists, then it is called.
It returns two values:
the current number of valid field elements and an offset.
The number of valid elements may not match \verb|dbAddr.no_elements|, which is really the maximum number of elements allowed.
The offset is for use by records which implement circular buffers, and provides the offset to the current beginning of the array data.

\subsection{Put Routines}

\subsubsection{dbPutField}

Change the value of a process variable, format:

\begin{verbatim}
long dbPutField(
    struct dbAddr *paddr,
    short dbrType,   /* DBR_xxx */
    void *pbuffer,  /* ptr to data */
    long nRequest); /* number of elements to write */
\end{verbatim}

\index{dbPutField}This routine is responsible for accepting data in one of the \verb|DBR_xxx| formats, converting it as necessary, and modifying the database.
Similar to \verb|dbGetField|, this routine calls one of a number of conversion routines to do the actual conversion and relies on record support routines to handle arrays and other special cases.

It should be noted that routine \verb|dbPut| does most of the work.
The actual algorithm for \verb|dbPutField| is:

\begin{enumerate}
\item If the \verb|DISP| field is \verb|TRUE| then, unless it is the \verb|DISP| field itself which is being modified, the field is not written.

\item The record is locked.

\item \verb|dbPut| is called.

\item If the \verb|dbPut| is successful then:

If this is the \verb|PROC| field or if both of the following are \verb|TRUE|:
1) the field is a process passive field,
2) the record is passive.

\begin{enumerate}

\item If the record is already active, ask for the record to be reprocessed when it completes.

\item Call \verb|dbScanPassive| after setting \verb|putf| \verb|TRUE| to show the process request came from \verb|dbPutField|.

\end{enumerate}

\item The record is unlocked.

\end{enumerate}

\subsubsection{dbPutLink and dbPutLinkValue}

Change the value referenced by a database link, format:

\begin{verbatim}
long dbPutLink(
    struct db_link  *plink, /* ptr to link field */
    short dbrType,          /* DBR_xxx */
    void *pbuffer,          /* ptr to data to write */
    long nRequest);         /* number of elements to write */
\end{verbatim}

\index{dbPutLink}\verb|dbPutLink| is actually a macro that calls \verb|dbPutLinkValue| and can reference its arguments more than once.
The macro skips the call for constant links.
User code should never call \verb|dbPutLinkValue|.

This routine is called by database access itself and by record support and/or device support routines in order to put values into other database records via output links.

For Channel Access links it calls \verb|dbCaPutLink|.

For database links it performs the following functions:

\begin{enumerate}
\item Calls \verb|dbPut|.

\item Implements maximize severity.

\item If the field being referenced is \verb|PROC| or if both of the following are true: 1) \verb|process_passive| is \verb|TRUE| and 2) the record is passive then:

\begin{enumerate}

\item If the record is already active because of a \verb|dbPutField| request then ask for the record to be reprocessed when it completes.

\item otherwise call \verb|dbScanPassive|.

\end{enumerate}
\end{enumerate}

\subsubsection{dbPut}

Put a value to a database field, format:

\begin{verbatim}
long dbPut(
    struct dbAddr  *paddr,
    shortdbrType,/* DBR_xxx*/
    void*pbuffer,/*addr of data*/
    longnRequest);/*number of elements to write*/
\end{verbatim}

\index{dbPut}This routine is responsible for accepting data in one of the \verb|DBR_xxx| formats, converting it as necessary, and modifying 
the database.
Similar to \verb|dbGet|, this routine calls one of a number of conversion routines to do the actual conversion and relies on record support routines to handle arrays and other special cases.

\label{Process Notify Subsystem}
\subsection{Process Notify Subsystem}

\subsubsection{Introduction}

The Process Notify subsystem provides the following features:

\begin{enumerate}
\item Processes a record with notification of completion.
\item Put after the record is claimed but before before the process.
\item Get after the process but before the record is released.
\item put, then process, then get.
\end{enumerate}

A process request will be issued if any of the following is true:

\begin{itemize}
\item The requester has issued a processs request and record is passive.
\item The requester is doing a put, the record is passive, and either the field description is process passive or the field is PROC.
\item The requester has requested a processGet or a putProcessGet request and the record is passive.
\end{itemize}

At most one process is performed per \verb|dbProcessNotify| request.

\index{dbNotify.h}
\subsubsection{dbNotify.h}

The dbNotify.h header defines the following:

\index{dbProcessNotify}
\index{processNotifyStatus}
\index{processNotify}
\begin{verbatim}
typedef enum {
    processRequest,
    putProcessRequest,
    processGetRequest,
    putProcessGetRequest
} notifyRequestType;

typedef enum {
    putDisabledType,
    putFieldType,
    putType
} notifyPutType;

typedef enum {
    getFieldType,
    getType
} notifyGetType;

typedef enum {
    notifyOK,
    notifyCanceled,
    notifyError,
    notifyPutDisabled
} notifyStatus;

typedef struct processNotify {
    /* Fields for private use by dbNotify implementation: */
    ellCheckNode restartNode;
    void *       pnotifyPvt;
    /* Fields set by dbNotify: */
    notifyStatus status;
    int          wasProcessed; /* (0,1) => (no,yes) */
    /*Fields set by user: */
    notifyRequestType requestType;
    struct dbAddr *paddr;      /* set by dbNameToAddr*/
    int         (*putCallback)(struct processNotify *,notifyPutType type);
    void        (*getCallback)(struct processNotify *,notifyGetType type);
    void        (*doneCallback)(struct processNotify *);
    void *        usrPvt;       /* for private use of user */
} processNotify;

epicsShareFunc void dbProcessNotify(processNotify *pprocessNotify);
epicsShareFunc void dbNotifyCancel(processNotify *pprocessNotify);
\end{verbatim}

\subsubsection{Client Semantics}

The client must allocate an instance of \verb|processNotify|, which can be used for an arbitrary number of calls to \verb|dbProcessNotify|.
Before calling \verb|dbProcessNotify| the following fields must be given values:

\begin{itemize}
\item \verb|requestType| - The request type.

\item \verb|paddr| - A struct dbAddr, which is given values by a call to \verb|dbNameToAddr|.

\item \verb|putCallback| - If the request is a \verb|putProcessRequest| or a \verb|putProcessGetRequest| this must be given a value.
It is called before the record is processed.
This routine is expected to issue a database put.
The return value should be (0, 1) if the callback operation (was not, was) successful.

\item \verb|getCallback| - If the request is a \verb|processGetRequest| or a \verb|putProcessGetrequest| this must be given a value.
It is called after the record is processed but before the record is released.
This routine is expected to issue a database get.

\item \verb|doneCallback| - This must be given a value.
It is called after the record is processed and after the optional \verb|getCallback|.
This routine may issue a new \verb|dbProcessNotify| if desired.

\item \verb|userPvt| - A field for the client and its callback routines to use as needed; this pointer is not used by the processNotify code.
\end{itemize}

The \verb|notifyPutType| argument to \verb|putCallback| is one of these values:

\begin{itemize}
\item \verb|putDisabledType| - Puts are disabled.
The client must not issue a put.

\item \verb|dbPutFieldType| - The client may issue a \verb|dbPutField| request.
This is returned when \verb|paddr| refers to a link field.
For link fields the record will never be processed as a result of the \verb|dbProcessNotify|.

\item \verb|dbPutType| - The client can issue a dbPut request.
The record may or may not be processed after the client callback returns.
\end{itemize}

The \verb|notifyGetType| argument to \verb|getCallback| will be one of these values:

\begin{itemize}
\item \verb|getFieldType| - The client may issue a \verb|dbGetField| request.
This is returned when \verb|paddr| refers to a link field.
For link fields the record will never be processed as a result of the \verb|dbProcessNotify|.

\item \verb|getType| - The client may issue a \verb|dbGet| request.
\end{itemize}

The \verb|notifyStatus| argument to \verb|doneCallback|  is one of these values:

\begin{itemize}
\item \verb|notifyOK| - The \verb|dbProcessNotify| request was successful and the record was processed.
\item \verb|notifyNoProcessOK| - The \verb|dbProcessNotify| request was successful but the record was not processed.
\item \verb|notifyError| - An error occured.
\end{itemize}

Example code can be found in the routine \verb|dbtpn| which is defined in \verb|base/src/ioc/db/dbNotify.c|. It uses both \verb|putProcesssRequest| and \verb|processGetRequest|.

\subsubsection{Callback Device Support}

EPICS base provides soft device support that uses processNotify for both input and output record types. All use the device type name ``Asyn Soft Channel''.

The input types issue a \verb|processGetRequest|:
\begin{itemize}
\item \verb|devAiSoftCallback| - Supports aiRecord.
\item \verb|devBiSoftCallback| - Supports biRecord.
\item \verb|devMbbiSoftCallback| - Supports mbbiRecord.
\item \verb|devMbbiDirectSoftCallback| - Supports mbbiDirectRecord.
\item \verb|devLiSoftCallback| - Supports longinRecord.
\item \verb|devSiSoftCallback| - Supports stringinRecord.
\end{itemize}

The output types issue a channel access \verb|ca_put_callback| request.
\begin{itemize}
\item \verb|devAoSoftCallback| - Supports aoRecord.
\item \verb|devBoSoftCallback| - Supports boRecord.
\item \verb|devCalcoutSoftCallback| - Supports calcoutRecord.
\item \verb|devMbboSoftCallback| - Supports mbboRecord.
\item \verb|devMbboDirectSoftCallback| - Supports mbboDirectRecord.
\item \verb|devSiSoftCallback| - Supports longoutRecord.
\end{itemize}


\subsection{Utility Routines}

\subsubsection{dbBufferSize}

\index{dbBufferSize}
Determine the buffer size for a \verb|dbGetField| request, format:

\begin{verbatim}
long dbBufferSize(
    shortdbrType,/* DBR_xxx*/
    longoptions,/* options mask*/
    longnRequest);/* number of elements*/
\end{verbatim}

\index{dbBufferSize}This routine returns the number of bytes that will be returned to \verb|dbGetField| if the request type, options, and number of elements are specified as given to \verb|dbBufferSize|.
Thus it can be used to allocate storage for buffers.

NOTE: This should become a Channel Access routine

\subsubsection{dbValueSize}

\index{dbValueSize}
Determine the size a value field, format:

\begin{verbatim}
dbValueSize(short dbrType); /* DBR_xxx*/
\end{verbatim}

\index{dbValueSize}This routine returns the number of bytes for each element of type \verb|dbrType|.

NOTE: This should become a Channel Access routine

\subsubsection{dbGetRset}

\index{dbGetRest}
Get address of a record support entry table.

Format:

\begin{verbatim}
struct rset *dbGetRset(DBADDR *paddr);
\end{verbatim}

\index{dbGetRset}This routine returns the address of the record support entry table for the record referenced by the \verb|DBADDR|.

\subsubsection{dbIsValueField}

\index{dbIsValueField}
Is this field the VAL field of the record?

Format:

\begin{verbatim}
int dbIsValueField(struct dbFldDes *pdbFldDes);
\end{verbatim}

\index{dbIsValueField}This is the routine that makes the \verb|get_value| record support routine obsolete.

\subsubsection{dbGetFieldIndex}

\index{dbGetFieldIndex}
Get field index.

Format:

\begin{verbatim}
int dbGetFieldIndex(DBADDR *paddr);
\end{verbatim}

\index{dbGetFieldIndex}Record support routines such as \verb|special| and \verb|cvt_dbaddr| need to know which field the \verb|DBADDR| references.
The include file describing the record contains define statements for each field.
\verb|dbGetFieldIndex| returns the index that can be matched against the define statements (normally via a switch statement).

\subsubsection{dbGetNelements}

\index{dbGetNelements}
Get number of elements in a field.

Format:

\begin{verbatim}
 long dbGetNelements(struct link *plink,long *nelements);
\end{verbatim}

\index{dbGetNelements}This sets *\verb|nelements| to the number of elements in the field referenced by plink.

\subsubsection{dbIsLinkConnected}

\index{dbIsLinkConnected}
Is the link connected.

Format:

\begin{verbatim}
int dbIsLinkConnected(struct link *plink);
\end{verbatim}

\index{dbIsLinkConnected}This routine returns (TRUE, FALSE) if the link (is, is not) connected.

\subsubsection{dbGetPdbAddrFromLink}

\index{dbGetPdbAddrFromLink}
Get address of DBADDR from link.

Format:

\begin{verbatim}
DBADDR *dbGetPdbAddrFromLink(struct link *plink);
\end{verbatim}

\index{dbGetPdbAddrFromLink}This macro returns the address of the DBADDR for a database link and NULL for all other link types.

\subsubsection{dbGetLinkDBFtype}

\index{dbGetLinkDBFtype}
Get field type of a link.

Format:

\begin{verbatim}
int dbGetLinkDBFtype(struct link *plink);
\end{verbatim}

\index{dbGetLinkDBFtype}\subsubsection{dbGetControlLimits}

\index{dbGetControlLimits}
Get Control Limits for link.

Format:

\begin{verbatim}
long dbGetControlLimits(struct link *plink,double *low, double *high);
\end{verbatim}

\subsubsection{dbGetGraphicLimits}

\index{dbGetGraphicLimits}
Get Graphic Limits for link.

Format:

\begin{verbatim}
long dbGetGraphicLimits(struct link *plink,double *low, double *high);
\end{verbatim}

\subsubsection{dbGetAlarmLimits}

\index{dbGetAlarmLimits}
Get Alarm Limits for link.

Format:

\begin{verbatim}
long dbGetAlarmLimits(struct link *plink,

double lolo,double *low, double *high,double hihi);
\end{verbatim}

\subsubsection{dbGetPrecision}

\index{dbGetPrecision}
Get Precision for link.

Format:

\begin{verbatim}
long dbGetPrecision(struct link *plink,short *precision);
\end{verbatim}

\subsubsection{dbGetUnits}

\index{dbGetUnits}
Get Units for link.

Format:

\begin{verbatim}
long dbGetUnits(struct link *plink,char *units,int unitsSize);
\end{verbatim}

\subsubsection{dbGetSevr}

\index{dbGetSevr}
Get Severity for link.

Format:

\begin{verbatim}
long dbGetSevr(struct link *plink,short *sevr);
\end{verbatim}

\subsubsection{dbGetTimeStamp}

\index{dbGetTimeStamp}
Get Time Stamp for record containing link.

Format:

\begin{verbatim}
long dbGetTimeStamp(struct link *plink,TS_STAMP *pstamp);
\end{verbatim}

\subsection{Attribute Routine}

\subsubsection{dbPutAttribute}

\index{dbPutAttribute}
Give a value to a record attribute.

\begin{verbatim}
long dbPutAttribute(char *recordTypename,
    char *name,char*value);
\end{verbatim}

\index{dbPutAttribute}This sets the record attribute \verb|name| for record type \verb|recordTypename| to \verb|value|.
For example the following would set the version for the ai record.

\begin{verbatim}
dbPutAttribute("ai","VERS","V800.6.95")
\end{verbatim}

\subsection{Process Routines}

\subsubsection{dbScanPassive}

dbScanLink

dbScanFwdLink

Process record if it is passive, format:

\begin{verbatim}
long dbScanPassive(
    struct dbCommon  *pfrom,
    struct dbCommon  *pto);   /* addr of record*/
long dbScanLink(
    struct dbCommon *pfrom, struct dbCommon *pto);
void dbScanFwdLink(struct link *plink);
\end{verbatim}

\index{dbScanPassive}
\index{dbScanLink}
\index{dbScanFwdLink}
 \verb|dbScanPassive| and \verb|dbScanLink| are given the record requesting the scan, which may be \verb|NULL|, and the record to be processed.
If the record is passive and \verb|pact| is \verb|FALSE| then \verb|dbProcess| is called.
Note that these routine are called by \verb|dbGetLink|, \verb|dbPutField|, and by \verb|recGblFwdLink|.

\verb|dbScanFwdLink| is given a link that must be a forward link field.
It follows the rules for scanning a forward link.
That is for DB\_LINKs it calls dbScanPassive and for CA\_LINKS it does a dbCaPutLink if the PROC field of record is being addressed.

\subsubsection{dbProcess }

Request that a database record be processed, format:

\begin{verbatim}
long dbProcess(struct dbCommom  *precord);
\end{verbatim}

\index{dbProcess}Request that record be processed.
Record processing is described in detail below.

\section{Runtime Link Modification}

Database links can be changed at run time but only via a channel access client, i.e. via calls to \verb|dbPutField| but not to \verb|dbPutLink|.
The following restrictions apply:

\begin{itemize}
\item The date type may be \verb|DBR_STRING| or a nil-terminated array of DBR\_CHAR or DBR\_UCHAR characters

\item If a link is being changed to a different hardware link type then the \verb|DTYP| field must be set before the link field.

\item The syntax for the string is exactly the same as described for link fields in chapter ``Database Definition"

\end{itemize}

\section{Channel Access Monitors}

\index{Channel Access Monitors}
There are facilities within the Channel Access communication infrastructure which allow the value of a process variable to be monitored by a channel access client.
It is a responsibility of record support (and db common) to notify the channel access server when the internal state of a process variable has been modified.
State changes can include changes in the value of a process variable and also changes in the alarm state of a process variable.
The routine \verb|db_post_events| is called to inform the channel access server that a process variable state change event has occurred.

\begin{verbatim}
#include <caeventmask.h>

int db_post_events(void *precord, void *pfield,
unsigned intselect);
\end{verbatim}

\index{db\_post\_events}
The first argument, ``precord", should be passed a pointer to the record which is posting the event(s).
The second argument, ``pfield", should be passed a pointer to the field in the record that contains the process variable that has been modified.
The third argument, ``select", should be passed an event select mask.
This mask can be any logical or combination of \{DBE\_VALUE, DBE\_LOG, DBE\_ALARM\}.
A description of the purpose of each flag in the event select mask follows.

\begin{itemize}
\item DBE\_VALUE This indicates that a significant change in the process variable's value has occurred.
A significant change is often determined by the magnitude of the monitor ``dead band" field in the record.

\item DBE\_LOG This indicates that a change in the process variable's value significant to archival clients has occurred.
A significant change to archival clients is often determined by the magnitude of the archive ``dead band" field in the record.

\item DBE\_ALARM This indicates that a change in the process variable's alarm state has occurred.

\end{itemize}

The function \verb|db_post_events| returns 0 if it is successful and -1 if it fails.
It appears to be common practice within EPICS record support to ignore the status from \verb|db_post_events|.
At this time \verb|db_post_events| always returns 0 (success).
Because so many records at this time depend on this behavior it is unlikely that it will be changed in the future.

The function \verb|db_post_events| is written so that record support will never be blocked attempting to post an event because a slow client is not able to process events fast enough.
Each call to \verb|db_post_events| causes the current value, alarm status, and time stamp for the field to be copied into a ring buffer.
The thread calling \verb|db_post_events| will not be delayed by any network or memory allocation overhead.
A lower priority thread in the server is responsible for transferring the events in the event queue to the channel access clients that may be monitoring the process variable.

Currently, when an event is posted for a DBF\_STRING field or a field containing array data the value is NOT saved in the ring buffer and the client will receive whatever value happens to be in the field when the lower priority thread transfers 
the event to the client.
This behavior may be improved in the future.

\section{Lock Set Routines}

User code only calls \verb|dbScanLock| and \verb|dbScanUnlock|.
All other routines are called by \verb|iocCore|.

\subsubsection{dbScanLock}

Lock a lock set:

\begin{verbatim}
long void dbScanLock(struct dbCommon *precord);
\end{verbatim}

\index{dbScanLock}Lock the lock set to which the specified record belongs.

\subsubsection{dbScanUnlock}

Unlock a lock set:

\begin{verbatim}
long void dbScanUnlock(struct dbCommon *precord);
\end{verbatim}

\index{dbScanUnlock}Lock the lock set to which the specified record belongs

\subsubsection{dbLockGetLockId}

Get lock set id:

\begin{verbatim}
long dbLockGetLockId(struct dbCommon *precord);
\end{verbatim}

\index{dbLockGetLockId}Each lock set is assigned a unique ID.
This routine retrieves it.
This is most useful to determine if two records are in the same lock set.

\subsubsection{dbLockInitRecords}

Determine lock sets for each record in database.

\begin{verbatim}
void dbLockInitRecords(dbBase *pdbbase);
\end{verbatim}

\index{dbLockInitRecords}Called by \verb|iocInit|.

\subsubsection{dbLockSetMerge}

Merge records into same lock set.

\begin{verbatim}
void dbLockSetMerge(struct dbCommon *pfirst,
    struct dbCommon *psecond);
\end{verbatim}

\index{dbLockSetMerge}
If specified records are not in same lock set the lock sets are merged.
Called by dbLockInitRecords and also when links are modified by \verb|dbPutField|.

\subsubsection{dbLockSetSplitSl}

Recompute lock sets for given lock set

\begin{verbatim}
void dbLockSetSplit(struct dbCommon *psource);
\end{verbatim}

\index{dbLockSetSplit}This is called when \verb|dbPutField| modifies links.

\subsubsection{dbLockSetGblLock}

Global lock for modifying links.

\begin{verbatim}
void dbLockSetGblLock(void);
\end{verbatim}

\index{dbLockSetGblLock}Only one task at a time can modify link fields.
This routine provides a global lock to prevent conflicts.

\subsubsection{dbLockSetGblUnlock}

Unlock the global lock.

\begin{verbatim}
void dbLockSetGblUnlock(void);
\end{verbatim}

\index{dbLockSetGblUnlock}\subsubsection{dbLockSetRecordLock}

If record is not already scan locked lock it.

\begin{verbatim}
void dbLockSetRecordLock(struct dbCommon *precord);
\end{verbatim}

\index{dbLockSetRecordLock}\section{Channel Access Database Links}

The routines described here are used to create and manipulate Channel Access connections from database input or output links.
At IOC initialization an attempt is made to convert all process variable links to database links.
For any link that fails, it is assumed that the link is a Channel Access link, i.e. a link to a process variable defined in another IOC.
The routines described here are used to manage these links.
User code never needs to call these routines.
They are automatically called by iocInit and database access.

At \verb|iocInit| time a task \verb|dbCaLink| is spawned.
This task is a channel access client that issues channel access requests for all channel access links in the database.
For each link a channel access search request is issued.
When the search succeeds a channel access monitor is established.
The monitor is issued specifying \verb|ca_field_type| and \verb|ca_element_count|.
A buffer is also allocated to hold monitor return data as well as severity.
When \verb|dbCaGetLink| is called data is taken from the buffer, converted if necessary, and placed in the location specified by the \verb|pbuffer| 
argument.

When the first \verb|dbCaPutLink| is called for a link an output buffer is allocated, again using \verb|ca_field_type| and \verb|ca_element_count|.
The data specified by the pbuffer argument is converted and stored in the buffer.
A request is then made to \verb|dbCaLink| task to issue a \verb|ca_put|.
Subsequent calls to \verb|dbCaPutLink| reuse the same buffer.

\subsection{Basic Routines}

Except for dbCaPutLinkCallback, these routines are normally only called by database access, i.e. they are not called by record support modules.

\subsubsection{dbCaLinkInit}

Called by \verb|iocInit| to initialize the \verb|dbCa| library

\begin{verbatim}
void dbCaLinkInit(void);
\end{verbatim}

\index{dbCaLinkInit}\subsubsection{dbCaAddLink}

Add a new channel access link

\begin{verbatim}
void dbCaAddLink(struct link *plink);
\end{verbatim}

\index{dbCaAddLink}\subsubsection{dbCaAddLinkCallback}

\begin{verbatim}
void dbCaAddLinkCallback(struct link *plink,
    dbCaCallback connect,dbCaCallback monitor,void *userPvt);
\end{verbatim}

\index{dbCaAddLinkCallback}\verb|connect| will be called whenever the link connects or disconnects.
\verb|monitor| will be called whenever a monitor event occurs.
\verb|connect| and or \verb|monitor| may be null.

\subsubsection{dbCaRemoveLink}

Remove channel access link.

\begin{verbatim}
void dbCaRemoveLink(struct link *plink);
\end{verbatim}

\index{dbCaRemoveLink}
\subsubsection{dbCaGetLink}

Get link value

\begin{verbatim}
long dbCaGetLink(struct link *plink,short dbrType,
    void *pbuffer,unsigned short *psevr,long *nRequest);
\end{verbatim}

\index{dbCaGetLink}
\subsubsection{dbCaPutLink}

Put link value

\begin{verbatim}
long dbCaPutLink(struct link *plink,short dbrType,
    void *buffering nRequest);
\end{verbatim}

\index{dbCaPutLink}
\subsubsection{dbCaPutLinkCallback}

This is meant for use by device or record support that wants a put to complete before completing record processing.

\begin{verbatim}
long dbCaPutLinkCallback(struct link *plink,short dbrType,
const void *pbuffer,long nRequest,dbCaPutCallback callback);
\end{verbatim}

\index{dbCaPutLinkCallback}
\index{devAoSoftCallback.c}
\textless{}base\textgreater{}/src/std/dev/devAoSoftCallback.c provides an example of how to use this function.
It contains:

\begin{verbatim}
static long write_ao(aoRecord *pao)
{
    struct link *plink = &pao->out;
    long status;

    if(pao->pact) return(0);
    if(plink->type!=CA_LINK) {
        status = dbPutLink(&pao->out,DBR_DOUBLE,&pao->oval,1);
        return(status);
    }
    status = dbCaPutLinkCallback(plink,DBR_DOUBLE,&pao->oval,1,
                (dbCaCallback)dbCaCallbackProcess,plink);
    if(status) {
        recGblSetSevr(pao,LINK_ALARM,INVALID_ALARM);
        return(status);
    }
    pao->pact = TRUE;
    return(0);
}
\end{verbatim}

What happens is the following:

\begin{description}

\item When the record is processed write\_ao is called with pact=0.

\begin{description}

\item If the link is not a CA\_LINK it just calls dbPutLink.
It leaves pact 0.
Thus record support completes.

\item If it is a CA\_LINK it calls dbCaPutLinkCallback and sets pact true.
Thus record is asynchronous.

\end{description}

\item If the record is asynchrnous then sometime later dbCaCallbackProcess is called.
It calls the process routine of record support, which calls write\_ao with pact true.
write\_ao just returns success.
Record support then completes the second phase of record processing.

\end{description}

There is a possibility that the link is changed between the two phases of record processing.
If this happens the user supplied callback will still get called exactly once but the link may have been modified.

\subsection{Attributes of Link}

The routines in this section are meant for use by device support to find out information about link fields.
They must be called with dbScanLock held, i.e. normally they are called by the read or write method provided by device support.

\subsubsection{dbCaIsLinkConnected}

Is Channel Connected

\begin{verbatim}
int dbCaIsLinkConnected(struct link *plink)
\end{verbatim}

\index{dbCaIsLinkConnected}This routine returns (TRUE, FALSE) if the link (is, is not) connected.

\subsubsection{dbCaGetNelements}

Get Number of Elements

\begin{verbatim}
long dbCaGetNelements(struct link *plink,long *nelements);
\end{verbatim}

\index{dbCaGetNelements}This call, which returns an error if the link is not connected, sets the native number of elements.

\subsubsection{dbCaGetSevr}

Get Alarm Severity

\begin{verbatim}
long dbCaGetSevr(struct link *plink,short *severity);
\end{verbatim}

\index{dbCaGetSevr}This call, which returns an error if the link is not connected, sets the alarm severity.

\subsubsection{dbCaGetTimeStamp}

Get Time Stamp

\begin{verbatim}
long dbCaGetTimeStamp(struct link *plink,TS_STAMP *pstamp));
\end{verbatim}

\index{dbCaGetTimeStamp}This call, which returns an error if the link is not connected, sets pstamp to the time obtained by the last CA monitor.

\subsubsection{dbCaGetLinkDBFtype}

Get link type

\begin{verbatim}
int dbCaGetLinkDBFtype(struct link *plink);
\end{verbatim}

\index{dbCaGetLinkDBFtype}This call, which returns an error if the link is not connected, returns the field type.

\subsubsection{dbCaGetAttributes}

Get Attributes

\begin{verbatim}
long dbCaGetAttributes(struct link *plink,
    void (*callback)(void *usrPvt),void *usrPvt);
\end{verbatim}

\index{dbCaGetAttributes}When ever dbCa receives a connection it issues a CA get request to obtain the control, graphic, and alarm limits and to obtain the precision and units.
By calling dbCaGetAttributes the caller can be notified when this get completes.

\subsubsection{dbCaGetControlLimits}

Get Control Limits

\begin{verbatim}
long dbCaGetControlLimits(struct link *plink,double *low, double *high);
\end{verbatim}

\index{dbCaGetControlLimits}This call returns an error if the link is not connected or if the CA get request for limits, etc. has not completed.
If it returns success it has set the control limits.

\subsubsection{dbCaGetGraphicLimits}

Get graphic Limits

\begin{verbatim}
long dbCaGetGraphicLimits(struct link *plink,double *low, double *high);
\end{verbatim}

\index{dbCaGetGraphicLimits}This call returns an error if the link is not connected or if the CA get request for limits, etc. has not completed.
If it returns success it has set the graphic limits.

\subsubsection{dbCaGetAlarmLimits}

Get Alarm Limits

\begin{verbatim}
long dbCaGetAlarmLimits(struct link *plink,
    double *lolo, double *low, double *high, double *hihi);
\end{verbatim}

\index{dbCaGetAlarmLimits}This call returns an error if the link is not connected or if the CA get request for limits, etc. has not completed.
If it returns success it has set the alarm limits.

\subsubsection{dbCaGetPrecision}

Get Precision

\begin{verbatim}
long dbCaGetPrecision(struct link *plink,short *precision);
\end{verbatim}

\index{dbCaGetPrecision}This call returns an error if the link is not connected or if the CA get request for limits, etc. has not completed.
If it returns success it has set the precision.

\subsubsection{dbCaGetUnits}

Get Units

\begin{verbatim}
long dbCaGetUnits(struct link *plink,char *units,int unitsSize);
\end{verbatim}

\index{dbCaGetUnits}This call returns an error if the link is not connected or if the CA get request for limits, etc. has not completed.
If it returns success it has set the units.
